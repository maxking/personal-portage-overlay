commit c1fcd643c762bc6cdf5916cbc525e5a2a9c9ad0e
Author: Stefan Junker (root) <mail@stefanjunker.de>
Date:   Fri Apr 17 13:56:24 2015 -0700

    add codeeditor module

diff --git a/simso/gui/codeeditor/__init__.py b/simso/gui/codeeditor/__init__.py
new file mode 100644
index 0000000..2962b0a
--- /dev/null
+++ b/simso/gui/codeeditor/__init__.py
@@ -0,0 +1,71 @@
+# -*- coding: utf-8 -*-
+# Copyright (C) 2013, the codeeditor development team
+#
+# IEP is distributed under the terms of the (new) BSD License.
+# The full license can be found in 'license.txt'.
+
+""" CodeEditor
+
+A full featured code editor component based on QPlainTextEdit.
+
+"""
+
+#from .manager import Manager
+from .base import CodeEditorBase
+
+from .extensions.appearance import (    HighlightCurrentLine,
+                                        FullUnderlines,
+                                        IndentationGuides,
+                                        CodeFolding,
+                                        LongLineIndicator,
+                                        ShowWhitespace,
+                                        ShowLineEndings,
+                                        Wrap,
+                                        LineNumbers,
+                                        SyntaxHighlighting,
+                                        BreakPoints,
+                                    )
+from .extensions.behaviour import (     Indentation,
+                                        HomeKey,
+                                        EndKey,
+                                        NumpadPeriodKey,
+                                        AutoIndent,
+                                        PythonAutoIndent,
+                                   )
+#from .extensions.autocompletion import AutoCompletion
+#from .extensions.calltip import Calltip
+
+
+# Order of superclasses: first the extensions, then CodeEditorBase
+# The first superclass is the first extension that gets to handle each key
+#
+class CodeEditor(
+    HighlightCurrentLine,
+    FullUnderlines,
+    IndentationGuides,
+    CodeFolding,
+    LongLineIndicator,
+    ShowWhitespace,
+    ShowLineEndings,
+    Wrap,
+    BreakPoints,
+    LineNumbers,
+
+    # AutoCompletion, #Escape: first remove autocompletion,
+    # Calltip,               #then calltip
+
+    Indentation,
+    HomeKey,
+    EndKey,
+    NumpadPeriodKey,
+
+    AutoIndent,
+    PythonAutoIndent,
+
+    SyntaxHighlighting,
+
+    CodeEditorBase):  # CodeEditorBase must be the last one in the list
+    """
+    CodeEditor with all the extensions
+    """
+    pass
diff --git a/simso/gui/codeeditor/base.py b/simso/gui/codeeditor/base.py
new file mode 100644
index 0000000..8675d54
--- /dev/null
+++ b/simso/gui/codeeditor/base.py
@@ -0,0 +1,837 @@
+# -*- coding: utf-8 -*-
+# Copyright (C) 2013, the codeeditor development team
+#
+# IEP is distributed under the terms of the (new) BSD License.
+# The full license can be found in 'license.txt'.
+
+"""
+The base code editor class.
+
+
+"""
+
+"""
+WRITING EXTENSIONS FOR THE CODE EDITOR
+
+The Code Editor extension mechanism works solely based on inheritance.
+Extensions can override event handlers (e.g. paintEvent, keyPressEvent). Their
+default behaviour should be to call their super() event handler. This way,
+events propagate through the extensions following Python's method resolution
+order (http://www.python.org/download/releases/2.3/mro/).
+
+A 'fancy' code editor with extensions is created like:
+
+class FancyEditor( Extension1, Extension2, ... CodeEditorBase):
+    pass
+
+The order of the extensions does usually matter! If multiple Extensions process
+the same key press, the first one has the first chance to consume it.
+
+OVERRIDING __init__
+
+An extensions' __init__ method (if required) should look like this:
+class Extension:
+    def __init__(self, *args, extensionParam1 = 1, extensionParam2 = 3, **kwds):
+        super().__init__(*args, **kwds)
+        some_extension_init_stuff()
+        
+Note the following points:
+ - All parameters have default values
+ - The use of *args passes all non-named arguments to its super(), which
+   will therefore end up at the QPlainTextEdit constructor. As a consequence,
+   the parameters of the exentsion can only be specified as named arguments
+ - The use of **kwds ensures that parametes that are not defined by this 
+   extension, are passed to the next extension(s) in line.
+ - The call to super().__init__ is the first thing to do, this ensures that at
+   least the CodeEditorBase and QPlainTextEdit, of which the CodeEditorBase is
+   derived, are initialized when the initialization of the extension is done
+
+OVERRIDING keyPressEvent
+
+When overriding keyPressEvent, the extension has several options when an event
+arrives:
+ - Ignore the event
+     In this case, call super().keyPressEvent(event) for other extensions or the
+     CodeEditorBase to process the event
+ - Consume the event
+     In order to prevent other next extensions or the CodeEditorBase to react
+     on the event, return without calling the super().keyPressEvent
+ - Do something based on the event, and do not let the event propagate
+     In this case, do whatever action is defined by the extension, and do not
+     call the super().keyPressEvent
+ - Do something based on the event, and let the event propagate
+     In this case, do whatever action is defined by the extension, and do call
+     the super().keyEvent
+
+In any case, the keyPressEvent should not return a value (i.e., return None).
+Furthermore, an extension may also want to perform some action *after* the
+event has been processed by the next extensions and the CodeEditorBase. In this
+case, perform that action after calling super().keyPressEvent
+
+OVERRIDING paintEvent
+
+Then overriding the paintEvent, the extension may want to paint either behind or
+in front of the CodeEditorBase text. In order to paint behind the text, first
+perform the painting, and then call super().paintEvent. In order to paint in
+front of the text, first call super().paintEvent, then perform the painting.
+
+As a result, the total paint order is as follows for the example of the
+FancyEditor defined above:
+- First the extensions that draw behind the text (i.e. paint before calling
+  super().paintEvent, in the order Extension1, Extension2, ...
+- then the CodeEditorBase, with the text
+- then the extensions that draw in front of the text (i.e. call 
+  super().paintEvent before painting), in the order ..., Extension2, Extension1
+  
+OVERRIDING OTHER EVENT HANDLERS
+
+When overriding other event handlers, be sure to call the super()'s event
+handler; either before or after your own actions, as appropriate
+
+OTHER ISSUES
+
+In order to avoid namespace clashes among the extensions, take the following
+into account:
+ - Private members should start with __ to make ensure no clashes will occur
+ - Public members / methods should have names that clearly indicate which
+   extension they belong to (e.g. not cancel but autocompleteCancel)
+ - Arguments of the __init__ method should also have clearly destictive names
+
+"""
+
+import sys
+from .qt import QtGui,QtCore
+Qt = QtCore.Qt
+
+from .misc import DEFAULT_OPTION_NAME, DEFAULT_OPTION_NONE, ce_option
+from .misc import callLater, ustr
+from .manager import Manager
+from .highlighter import Highlighter
+from .style import StyleFormat, StyleElementDescription
+
+
+class CodeEditorBase(QtGui.QPlainTextEdit):
+    """ The base code editor class. Implements some basic features required
+    by the extensions.
+    
+    """
+    
+    # Style element for default text and editor background
+    _styleElements = [('Editor.text', 'The style of the default text. ' + 
+                        'One can set the background color here.',
+                        'fore:#000,back:#fff',)]
+    
+    # Signal emitted after style has changed
+    styleChanged = QtCore.Signal()
+    
+    # Signal emitted after font (or font size) has changed
+    fontChanged = QtCore.Signal()
+    
+    # Signal to indicate a change in breakpoints. Only emitted if the
+    # appropriate extension is in use
+    breakPointsChanged = QtCore.Signal(object)
+    
+    
+    def __init__(self,*args, **kwds):
+        super(CodeEditorBase, self).__init__(*args)
+        
+        # Set font (always monospace)
+        self.__zoom = 0
+        self.setFont()
+        
+        # Create highlighter class 
+        self.__highlighter = Highlighter(self, self.document())
+        
+        # Set some document options
+        option = self.document().defaultTextOption()
+        option.setFlags(    option.flags() | option.IncludeTrailingSpaces |
+                            option.AddSpaceForLineAndParagraphSeparators )
+        self.document().setDefaultTextOption(option)
+        
+        # When the cursor position changes, invoke an update, so that
+        # the hihghlighting etc will work
+        self.cursorPositionChanged.connect(self.viewport().update) 
+        
+        # Init styles to default values
+        self.__style = {}
+        for element in self.getStyleElementDescriptions():
+            self.__style[element.key] = element.defaultFormat
+        
+        # Connext style update
+        self.styleChanged.connect(self.__afterSetStyle)
+        self.__styleChangedPending = False
+        
+        # Init margins
+        self._leftmargins = []
+        
+        # Init options now. 
+        # NOTE TO PEOPLE DEVELOPING EXTENSIONS:
+        # If an extension has an __init__ in which it first calls the 
+        # super().__init__, this __initOptions() function will be called, 
+        # while the extension's init is not yet finished.        
+        self.__initOptions(kwds)
+        
+        # Define solarized colors
+        base03  = "#002b36"
+        base02  = "#073642"
+        base01  = "#586e75"
+        base00  = "#657b83"
+        base0   = "#839496"
+        base1   = "#93a1a1"
+        base2   = "#eee8d5"
+        base3   = "#fdf6e3"
+        yellow  = "#b58900"
+        orange  = "#cb4b16"
+        red     = "#dc322f"
+        magenta = "#d33682"
+        violet  = "#6c71c4"
+        blue    = "#268bd2"
+        cyan    = "#2aa198"
+        green   = "#859900"
+        
+        if True: # Light vs dark
+            #back1, back2, back3 = base3, base2, base1 # real solarised
+            back1, back2, back3 = "#fff", base2, base1 # crispier
+            fore1, fore2, fore3, fore4 = base00, base01, base02, base03
+        else:
+            back1, back2, back3 = base03, base02, base01
+            fore1, fore2, fore3, fore4 = base0, base1, base2, base3
+        
+        test_numbers  = 90 + 0000 + 1
+        # todo: proper testing of syntax style
+        
+        # Define style
+        S  = {}
+        S["Editor.text"] = "back:%s, fore:%s" % (back1, fore1)
+        S['Syntax.identifier'] = "fore:%s, bold:no, italic:no, underline:no" % fore1
+        S["Syntax.nonidentifier"] = "fore:%s, bold:no, italic:no, underline:no" % fore2
+        S["Syntax.keyword"] = "fore:%s, bold:yes, italic:no, underline:no" % fore2
+        
+        
+        S["Syntax.functionname"] = "fore:%s, bold:yes, italic:no, underline:no" % fore3
+        S["Syntax.classname"] = "fore:%s, bold:yes, italic:no, underline:no" % orange
+        
+        S["Syntax.string"] = "fore:%s, bold:no, italic:no, underline:no" % violet
+        S["Syntax.unterminatedstring"] = "fore:%s, bold:no, italic:no, underline:dotted" % violet
+        S["Syntax.python.multilinestring"] = "fore:%s, bold:no, italic:no, underline:no" % blue
+        
+        S["Syntax.number"] = "fore:%s, bold:no, italic:no, underline:no" % cyan
+        S["Syntax.comment"] ="fore:%s, bold:no, italic:no, underline:no" % yellow
+        S["Syntax.todocomment"] = "fore:%s, bold:no, italic:yes, underline:no" % magenta
+        S["Syntax.python.cellcomment"] = "fore:%s, bold:yes, italic:no, underline:full" % yellow
+        
+            
+        S["Editor.Long line indicator"] = "linestyle:solid, fore:%s" % back2
+        S["Editor.Highlight current line"] = "back:%s" % back2
+        S["Editor.Indentation guides"] = "linestyle:solid, fore:%s" % back2
+        S["Editor.Line numbers"] = "back:%s, fore:%s" % (back2, back3)
+        
+        # Apply style
+        self.setStyle(S)
+    
+    
+    def _setHighlighter(self, highlighterClass):
+        self.__highlighter = highlighterClass(self, self.document())
+       
+    ## Options
+    
+    def __getOptionSetters(self):
+        """ Get a dict that maps (lowercase) option names to the setter
+        methods.
+        """
+        
+        # Get all names that can be options
+        allNames = set(dir(self))
+        nativeNames = set(dir(QtGui.QPlainTextEdit))
+        names = allNames.difference(nativeNames)
+        
+        # Init dict of setter members
+        setters = {}
+        
+        for name in names:
+            # Get name without set
+            if name.lower().startswith('set'):
+                name = name[3:]
+            # Get setter and getter name
+            name_set = 'set' + name[0].upper() + name[1:]
+            name_get = name[0].lower() + name[1:]
+            # Check if both present
+            if not (name_set in names and name_get in names):
+                continue
+            # Get members
+            member_set = getattr(self, name_set)
+            member_get = getattr(self, name_get)
+            # Check if option decorator was used and get default value
+            for member in [member_set, member_get]:
+                if hasattr(member, DEFAULT_OPTION_NAME):
+                    defaultValue = member.__dict__[DEFAULT_OPTION_NAME]
+                    break
+            else:
+                continue
+            # Set default on both
+            member_set.__dict__[DEFAULT_OPTION_NAME] = defaultValue
+            member_get.__dict__[DEFAULT_OPTION_NAME] = defaultValue
+            # Add to list
+            setters[name.lower()] = member_set
+        
+        # Done
+        return setters
+    
+    
+    def __setOptions(self, setters, options):
+        """ Sets the options, given the list-of-tuples methods and an
+        options dict.
+        """
+        
+        # List of invalid keys
+        invalidKeys = []
+        
+        # Set options
+        for key1 in options:
+            key2 = key1.lower()
+            # Allow using the setter name
+            if key2.startswith('set'):
+                key2 = key2[3:]
+            # Check if exists. If so, call!
+            if key2 in setters:
+                fun = setters[key2]
+                val = options[key1]
+                fun(val)
+            else:
+                invalidKeys.append(key1)
+        
+        # Check if invalid keys were given
+        if invalidKeys:
+            print("Warning, invalid options given: " + ', '.join(invalidKeys))
+    
+    
+    def __initOptions(self, options=None):
+        """ Init the options with their default values.
+        Also applies the docstrings of one to the other.
+        """
+        
+        # Make options an empty dict if not given
+        if not options:
+            options = {}
+        
+        # Get setters
+        setters = self.__getOptionSetters()
+        
+        # Set default value
+        for member_set in setters.values():
+            defaultVal = member_set.__dict__[DEFAULT_OPTION_NAME]
+            if defaultVal != DEFAULT_OPTION_NONE:
+                try:
+                    member_set(defaultVal)
+                except Exception as why:
+                    print('Error initing option ', member_set.__name__)
+        
+        # Also set using given opions?
+        if options:
+            self.__setOptions(setters, options)
+    
+    
+    def setOptions(self, options=None, **kwargs):
+        """ setOptions(options=None, **kwargs)
+        
+        Set the code editor options (e.g. highlightCurrentLine) using
+        a dict-like object, or using keyword arguments (options given
+        in the latter overrule opions in the first).
+        
+        The keys in the dict are case insensitive and one can use the
+        option's setter or getter name.
+        
+        """
+        
+        # Process options
+        if options:
+            D = {}            
+            for key in options:
+                D[key] = options[key]
+            D.update(kwargs)
+        else:
+            D = kwargs
+        
+        # Get setters
+        setters = self.__getOptionSetters()
+        
+        # Go
+        self.__setOptions(setters, D)
+    
+    
+    ## Font
+    
+    def setFont(self, font=None):
+        """ setFont(font=None)
+        
+        Set the font for the editor. Should be a monospace font. If not,
+        Qt will select the best matching monospace font.
+        
+        """
+        
+        defaultFont = Manager.defaultFont()
+        
+        # Get font object
+        if font is None:
+            font = defaultFont
+        elif isinstance(font, QtGui.QFont):
+            pass
+        elif isinstance(font, str):
+            font = QtGui.QFont(font)
+        else:
+            raise ValueError("setFont accepts None, QFont or string.")
+        
+        # Hint Qt that it should be monospace
+        font.setStyleHint(font.TypeWriter, font.PreferDefault)
+        
+        # Get family, fall back to default if qt could not produce monospace
+        fontInfo = QtGui.QFontInfo(font)
+        if fontInfo.fixedPitch():
+            family = fontInfo.family() 
+        else:
+            family = defaultFont.family()
+        
+        # Get size: default size + zoom
+        size = defaultFont.pointSize() + self.__zoom
+        
+        # Create font instance
+        font = QtGui.QFont(family, size)
+        
+        # Set, emit and return
+        QtGui.QPlainTextEdit.setFont(self, font)
+        self.fontChanged.emit()
+        return font
+    
+    
+    def setZoom(self, zoom):
+        """ setZoom(zoom)
+        
+        Set the zooming of the document. The font size is always the default
+        font size + the zoom factor.
+        
+        The final zoom is returned, this may not be the same as the given
+        zoom factor if the given factor is too small.
+        
+        """
+        # Set zoom (limit such that final pointSize >= 1)
+        size = Manager.defaultFont().pointSize()
+        self.__zoom = int(max(1-size,zoom))
+        # Set font
+        self.setFont(self.fontInfo().family())
+        # Return zoom
+        return self.__zoom
+    
+    
+    ## Syntax / styling
+    
+    
+    @classmethod
+    def getStyleElementDescriptions(cls):
+        """ getStyleElementDescriptions()
+        
+        This classmethod returns a list of the StyleElementDescription 
+        instances used by this class. This includes the descriptions for
+        the syntax highlighting of all parsers.
+        
+        """ 
+        
+        # Collect members by walking the class bases
+        elements = []
+        def collectElements(cls, iter=1):
+            # Valid class?
+            if cls is object or cls is QtGui.QPlainTextEdit:
+                return
+            # Check members
+            if hasattr(cls, '_styleElements'):
+                for element in cls._styleElements:
+                    elements.append(element)
+            # Recurse
+            for c in cls.__bases__:
+                collectElements(c, iter+1)
+        collectElements(cls)
+        
+        # Make style element descriptions
+        # (Use a dict to ensure there are no duplicate keys)
+        elements2 = {}
+        for element in elements:
+            # Check
+            if isinstance(element, StyleElementDescription):
+                pass
+            elif isinstance(element, tuple):
+                element = StyleElementDescription(*element)
+            else:
+                print('Warning: invalid element: ' + repr(element))
+            # Store using the name as a key to prevent duplicates
+            elements2[element.key] = element
+        
+        # Done
+        return list(elements2.values())
+    
+    
+    def getStyleElementFormat(self, name):
+        """ getStyleElementFormat(name)
+        
+        Get the style format for the style element corresponding with
+        the given name. The name is case insensitive and invariant to
+        the use of spaces.
+        
+        """
+        key = name.replace(' ','').lower()
+        try:
+            return self.__style[key]
+        except KeyError:
+            raise KeyError('Not a known style element name: "%s".' % name)
+    
+    
+    def setStyle(self, style=None, **kwargs):
+        """ setStyle(style=None, **kwargs)
+        
+        Updates the formatting per style element. 
+        
+        The style consists of a dictionary that maps style names to
+        style formats. The style names are case insensitive and invariant 
+        to the use of spaces.
+        
+        For convenience, keyword arguments may also be used. In this case,
+        underscores are interpreted as dots.
+        
+        This function can also be called without arguments to force the 
+        editor to restyle (and rehighlight) itself.
+        
+        Use getStyleElementDescriptions() to get information about the
+        available styles and their default values.
+        
+        Examples
+        --------
+        # To make the classname in underline, but keep the color and boldness:
+        setStyle(syntax_classname='underline') 
+        # To set all values for function names:
+        setStyle(syntax_functionname='#883,bold:no,italic:no') 
+        # To set line number and indent guides colors
+        setStyle({  'editor.LineNumbers':'fore:#000,back:#777', 
+                    'editor.indentationGuides':'#f88' })
+        
+        """
+        
+        # Combine user input
+        D = {}
+        if style:
+            for key in style:
+                D[key] = style[key]
+        if True:
+            for key in kwargs:
+                key2 = key.replace('_', '.')
+                D[key2] = kwargs[key]
+        
+        # List of given invalid style element names
+        invalidKeys = []
+        
+        # Set style elements
+        for key in D:
+            normKey = key.replace(' ', '').lower()
+            if normKey in self.__style:
+                #self.__style[normKey] = StyleFormat(D[key])
+                self.__style[normKey].update(D[key])
+            else:
+                invalidKeys.append(key)
+        
+        # Give warning for invalid keys
+        if invalidKeys:
+            print("Warning, invalid style names given: " + 
+                                                    ','.join(invalidKeys))
+        
+        # Notify that style changed, adopt a lazy approach to make loading
+        # quicker.
+        if self.isVisible():
+            callLater(self.styleChanged.emit)
+            self.__styleChangedPending = False
+        else:
+            self.__styleChangedPending = True
+    
+    
+    def showEvent(self, event):
+        super(CodeEditorBase, self).showEvent(event)
+        # Does the style need updating?
+        if self.__styleChangedPending:
+            callLater(self.styleChanged.emit)
+            self.__styleChangedPending = False
+    
+    
+    def __afterSetStyle(self):
+        """ _afterSetStyle()
+        
+        Method to call after the style has been set.
+        
+        """
+        
+        # Set text style using editor style sheet
+        format = self.getStyleElementFormat('editor.text')
+        ss = 'QPlainTextEdit{ color:%s; background-color:%s; }' %  (
+                            format['fore'], format['back'])
+        self.setStyleSheet(ss)
+        
+        # Make sure the style is applied
+        self.viewport().update()
+        
+        # Re-highlight
+        callLater(self.__highlighter.rehighlight)
+    
+    
+    ## Some basic options
+    
+    
+    @ce_option(4)
+    def indentWidth(self):
+        """ Get the width of a tab character, and also the amount of spaces
+        to use for indentation when indentUsingSpaces() is True.
+        """
+        return self.__indentWidth
+
+    def setIndentWidth(self, value):
+        value = int(value)
+        if value<=0:
+            raise ValueError("indentWidth must be >0")
+        self.__indentWidth = value
+        self.setTabStopWidth(self.fontMetrics().width('i'*self.__indentWidth))
+    
+    
+    @ce_option(False)
+    def indentUsingSpaces(self):
+        """Get whether to use spaces (if True) or tabs (if False) to indent
+        when the tab key is pressed
+        """
+        return self.__indentUsingSpaces
+    
+    def setIndentUsingSpaces(self, value):
+        self.__indentUsingSpaces = bool(value)
+        self.__highlighter.rehighlight()
+ 
+    
+    ## Misc
+    
+    def gotoLine(self, lineNumber):
+        """ gotoLine(lineNumber)
+        
+        Move the cursor to the block given by the line number 
+        (first line is number 1) and show that line.
+        
+        """
+        return self.gotoBlock(lineNumber-1)
+    
+    
+    def gotoBlock(self, blockNumber):
+        """ gotoBlock(blockNumber)
+        
+        Move the cursor to the block given by the block number 
+        (first block is number 0) and show that line.
+        
+        """
+        # Two implementatios. I know that the latter works, so lets
+        # just use that.
+        
+        cursor = self.textCursor()
+        #block = self.document().findBlockByNumber( blockNumber )
+        #cursor.setPosition(block.position())
+        cursor.movePosition(cursor.Start) # move to begin of the document
+        cursor.movePosition(cursor.NextBlock,n=blockNumber) # n blocks down
+        
+        try:
+            self.setTextCursor(cursor)
+        except Exception:
+            pass # File is smaller then the caller thought
+        self.centerCursor()
+    
+    def doForSelectedBlocks(self, function):
+        """ doForSelectedBlocks(function)
+        
+        Call the given function(cursor) for all blocks in the current selection
+        A block is considered to be in the current selection if a part of it is in
+        the current selection 
+        
+        The supplied cursor will be located at the beginning of each block. This
+        cursor may be modified by the function as required
+        
+        """
+        
+        #Note: a 'TextCursor' does not represent the actual on-screen cursor, so
+        #movements do not move the on-screen cursor
+        
+        #Note 2: when the text is changed, the cursor and selection start/end
+        #positions of all cursors are updated accordingly, so the screenCursor
+        #stays in place even if characters are inserted at the editCursor
+        
+        screenCursor = self.textCursor() #For maintaining which region is selected
+        editCursor = self.textCursor()   #For inserting the comment marks
+    
+        #Use beginEditBlock / endEditBlock to make this one undo/redo operation
+        editCursor.beginEditBlock()
+            
+        editCursor.setPosition(screenCursor.selectionStart())
+        editCursor.movePosition(editCursor.StartOfBlock)
+        # < :if selection end is at beginning of the block, don't include that
+        #one, except when the selectionStart is same as selectionEnd
+        while editCursor.position()<screenCursor.selectionEnd() or \
+                editCursor.position()<=screenCursor.selectionStart(): 
+            #Create a copy of the editCursor and call the user-supplied function
+            editCursorCopy = QtGui.QTextCursor(editCursor)
+            function(editCursorCopy)
+            
+            #Move to the next block
+            if not editCursor.block().next().isValid():
+                break #We reached the end of the document
+            editCursor.movePosition(editCursor.NextBlock)
+            
+        editCursor.endEditBlock()
+    
+    def doForVisibleBlocks(self, function):
+        """ doForVisibleBlocks(function)
+        
+        Call the given function(cursor) for all blocks that are currently
+        visible. This is used by several appearence extensions that
+        paint per block.
+        
+        The supplied cursor will be located at the beginning of each block. This
+        cursor may be modified by the function as required
+        
+        """
+
+        # Start cursor at top line.
+        cursor = self.cursorForPosition(QtCore.QPoint(0,0))
+        cursor.movePosition(cursor.StartOfBlock)
+
+        while True:            
+            # Call the function with a copy of the cursor
+            function(QtGui.QTextCursor(cursor))
+            
+            # Go to the next block (or not if we are done)
+            y = self.cursorRect(cursor).bottom() 
+            if y > self.height():
+                break #Reached end of the repaint area
+            if not cursor.block().next().isValid():
+                break #Reached end of the text
+            cursor.movePosition(cursor.NextBlock)
+        
+    def indentBlock(self, cursor, amount=1):
+        """ indentBlock(cursor, amount=1)
+        
+        Indent the block given by cursor.
+        
+        The cursor specified is used to do the indentation; it is positioned
+        at the beginning of the first non-whitespace position after completion
+        May be overridden to customize indentation.
+        
+        """
+        text = ustr(cursor.block().text())
+        leadingWhitespace = text[:len(text)-len(text.lstrip())]
+        
+        #Select the leading whitespace
+        cursor.movePosition(cursor.StartOfBlock)
+        cursor.movePosition(cursor.Right,cursor.KeepAnchor,len(leadingWhitespace))
+        
+        #Compute the new indentation length, expanding any existing tabs
+        indent = len(leadingWhitespace.expandtabs(self.indentWidth()))
+        if self.indentUsingSpaces():            
+            # Determine correction, so we can round to multiples of indentation
+            correction = indent % self.indentWidth()
+            if correction and amount<0:
+                correction = - (self.indentWidth() - correction) # Flip
+            # Add the indentation tabs
+            indent += (self.indentWidth() * amount) - correction
+            cursor.insertText(' '*max(indent,0))
+        else:
+            # Convert indentation to number of tabs, and add one
+            indent = (indent // self.indentWidth()) + amount
+            cursor.insertText('\t' * max(indent,0))
+    
+    
+    def dedentBlock(self, cursor):
+        """ dedentBlock(cursor)
+        
+        Dedent the block given by cursor.
+        
+        Calls indentBlock with amount = -1.
+        May be overridden to customize indentation.
+        
+        """
+        self.indentBlock(cursor, amount = -1)
+    
+    
+    def indentSelection(self):
+        """ indentSelection()
+        
+        Called when the current line/selection is to be indented.
+        Calls indentLine(cursor) for each line in the selection.
+        May be overridden to customize indentation.
+        
+        See also doForSelectedBlocks and indentBlock.
+        
+        """
+        self.doForSelectedBlocks(self.indentBlock)
+    
+    
+    def dedentSelection(self):
+        """ dedentSelection()
+        
+        Called when the current line/selection is to be dedented.
+        Calls dedentLine(cursor) for each line in the selection.
+        May be overridden to customize indentation.
+        
+        See also doForSelectedBlocks and dedentBlock.
+        
+        """
+        self.doForSelectedBlocks(self.dedentBlock)
+    
+    
+    def justifyText(self, linewidth=70):
+        """ justifyText(linewidth=70)
+        """
+        from .textutils import TextReshaper
+        
+        # Get cursor
+        cursor = self.textCursor()
+        
+        # Make selection include whole lines
+        pos1, pos2 = cursor.position(), cursor.anchor()
+        pos1, pos2 = min(pos1, pos2), max(pos1, pos2)
+        cursor.setPosition(pos1, cursor.MoveAnchor)
+        cursor.movePosition(cursor.StartOfBlock, cursor.MoveAnchor)
+        cursor.setPosition(pos2, cursor.KeepAnchor)
+        cursor.movePosition(cursor.EndOfBlock, cursor.KeepAnchor)
+        
+        # Use reshaper to create replacement text
+        reshaper = TextReshaper(linewidth)
+        reshaper.pushText(cursor.selectedText())
+        newText = reshaper.popText()
+        
+        # Update the selection
+        #self.setTextCursor(cursor) for testing
+        cursor.insertText(newText)
+    
+    
+    def addLeftMargin(self, des, func):
+        """ Add a margin to the left. Specify a description for the margin,
+        and a function to get that margin. For internal use.
+        """
+        assert des is not None
+        self._leftmargins.append((des, func))
+    
+    
+    def getLeftMargin(self, des=None):
+        """ Get the left margin, relative to the given description (which
+        should be the same as given to addLeftMargin). If des is omitted 
+        or None, the full left margin is returned.
+        """
+        margin = 0
+        for d, func in self._leftmargins:
+            if d == des:
+                break
+            margin += func()
+        return margin
+    
+    
+    def updateMargins(self):
+        """ Force the margins to be recalculated and set the viewport 
+        accordingly.
+        """
+        leftmargin = self.getLeftMargin()
+        self.setViewportMargins(leftmargin , 0, 0, 0)
diff --git a/simso/gui/codeeditor/extensions/__init__.py b/simso/gui/codeeditor/extensions/__init__.py
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/simso/gui/codeeditor/extensions/__init__.py
@@ -0,0 +5 @@
+# -*- coding: utf-8 -*-
+# Copyright (C) 2013, the codeeditor development team
+#
+# Codeeditor is distributed under the terms of the (new) BSD License.
+# The full license can be found in 'license.txt'.
diff --git a/simso/gui/codeeditor/extensions/appearance.py b/simso/gui/codeeditor/extensions/appearance.py
new file mode 100644
index 0000000..8b1cafe
--- /dev/null
+++ b/simso/gui/codeeditor/extensions/appearance.py
@@ -0,0 +1,875 @@
+# -*- coding: utf-8 -*-
+# Copyright (C) 2013, the codeeditor development team
+#
+# IEP is distributed under the terms of the (new) BSD License.
+# The full license can be found in 'license.txt'.
+
+"""
+Code editor extensions that change its appearance
+"""
+
+from ..qt import QtGui,QtCore
+Qt = QtCore.Qt
+
+from ..misc import ce_option
+from ..manager import Manager
+
+# todo: what about calling all extensions. CE_HighlightCurrentLine, 
+# or EXT_HighlightcurrentLine?
+
+class HighlightCurrentLine(object):
+    """
+    Highlight the current line
+    """
+    
+    # Register style element
+    _styleElements = [  (   'Editor.Highlight current line',
+                            'The background color of the current line highlight.',
+                            'back:#ffff99', 
+                        ) ]
+    
+    def highlightCurrentLine(self):
+        """ highlightCurrentLine()
+        
+        Get whether to highlight the current line.
+        
+        """
+        return self.__highlightCurrentLine
+    
+    @ce_option(True)
+    def setHighlightCurrentLine(self,value):
+        """ setHighlightCurrentLine(value)
+        
+        Set whether to highlight the current line.  
+        
+        """
+        self.__highlightCurrentLine = bool(value)
+        self.viewport().update()
+    
+    
+    def paintEvent(self,event):
+        """ paintEvent(event)
+        
+        Paints a rectangle spanning the current block (in case of line wrapping, this
+        means multiple lines)
+        
+        Paints behind its super()
+        """
+        if not self.highlightCurrentLine():
+            super(HighlightCurrentLine, self).paintEvent(event)
+            return
+        
+        # Get color
+        color = self.getStyleElementFormat('editor.highlightCurrentLine').back
+        
+        #Find the top of the current block, and the height
+        cursor = self.textCursor()
+        cursor.movePosition(cursor.StartOfBlock)
+        top = self.cursorRect(cursor).top()
+        cursor.movePosition(cursor.EndOfBlock)
+        height = self.cursorRect(cursor).bottom() - top + 1
+        
+        margin = self.document().documentMargin()
+        painter = QtGui.QPainter()
+        painter.begin(self.viewport())
+        painter.fillRect(QtCore.QRect(margin, top, 
+            self.viewport().width() - 2*margin, height),
+            color)
+        painter.end()
+        
+        super(HighlightCurrentLine, self).paintEvent(event)
+        
+        # for debugging paint events
+        #if 'log' not in self.__class__.__name__.lower():
+        #    print(height, event.rect().width())
+
+
+class IndentationGuides(object):
+    
+    # Register style element
+    _styleElements = [  (   'Editor.Indentation guides',
+                            'The color and style of the indentation guides.',
+                            'fore:#DDF,linestyle:solid', 
+                        ) ]
+    
+    def showIndentationGuides(self):
+        """ showIndentationGuides()
+        
+        Get whether to show indentation guides. 
+        
+        """
+        return self.__showIndentationGuides
+    
+    @ce_option(True)
+    def setShowIndentationGuides(self, value):
+        """ setShowIndentationGuides(value)
+        
+        Set whether to show indentation guides.
+        
+        """
+        self.__showIndentationGuides = bool(value)
+        self.viewport().update() 
+    
+    
+    def paintEvent(self,event):
+        """ paintEvent(event)
+        
+        Paint the indentation guides, using the indentation info calculated
+        by the highlighter.
+        """ 
+        super(IndentationGuides, self).paintEvent(event)
+
+        if not self.showIndentationGuides():
+            return
+        
+        # Get doc and viewport
+        doc = self.document()
+        viewport = self.viewport()
+        
+        # Get multiplication factor and indent width
+        indentWidth = self.indentWidth()
+        if self.indentUsingSpaces():
+            factor = 1 
+        else:
+            factor = indentWidth
+        
+        # Init painter
+        painter = QtGui.QPainter()
+        painter.begin(viewport)
+        
+        # Prepare pen
+        format = self.getStyleElementFormat('editor.IndentationGuides')
+        pen = QtGui.QPen(format.fore)
+        pen.setStyle(format.linestyle)
+        painter.setPen(pen)
+        offset = doc.documentMargin() + self.contentOffset().x()
+        
+        def paintIndentationGuides(cursor):
+            y3=self.cursorRect(cursor).top()
+            y4=self.cursorRect(cursor).bottom()            
+            
+            bd = cursor.block().userData()            
+            if bd and hasattr(bd, 'indentation') and bd.indentation:
+                for x in range(indentWidth, bd.indentation * factor, indentWidth):
+                    w = self.fontMetrics().width('i'*x) + offset
+                    w += 1 # Put it more under the block
+                    if w > 0: # if scrolled horizontally it can become < 0
+                        painter.drawLine(QtCore.QLine(w, y3, w, y4))
+ 
+        self.doForVisibleBlocks(paintIndentationGuides)
+        
+        # Done
+        painter.end()
+
+
+
+class FullUnderlines(object):
+    
+    def paintEvent(self,event):
+        """ paintEvent(event)
+        
+        Paint a horizontal line for the blocks for which there is a
+        syntax format that has underline:full. Whether this is the case
+        is stored at the blocks user data.
+        
+        """ 
+        super(FullUnderlines, self).paintEvent(event)
+   
+        painter = QtGui.QPainter()
+        painter.begin(self.viewport())
+ 
+        margin = self.document().documentMargin()
+        w = self.viewport().width()
+   
+        def paintUnderline(cursor):
+            y = self.cursorRect(cursor).bottom() 
+
+            bd = cursor.block().userData()            
+            try:
+                fullUnderlineFormat = bd.fullUnderlineFormat
+            except AttributeError:
+                pass  # fullUnderlineFormat may not be an attribute
+            else:
+                if fullUnderlineFormat is not None:
+                    # Apply pen
+                    pen = QtGui.QPen(fullUnderlineFormat.fore)
+                    pen.setStyle(fullUnderlineFormat.linestyle)
+                    painter.setPen(pen)
+                    # Paint
+                    painter.drawLine(QtCore.QLine(margin, y, w - 2*margin, y))            
+        
+        self.doForVisibleBlocks(paintUnderline)
+        
+        painter.end()
+
+
+
+class CodeFolding(object):
+    def paintEvent(self,event):
+        """ paintEvent(event)
+        
+        """ 
+        super(CodeFolding, self).paintEvent(event)
+   
+        return # Code folding code is not yet complete
+   
+        painter = QtGui.QPainter()
+        painter.begin(self.viewport())
+ 
+        margin = self.document().documentMargin()
+        w = self.viewport().width()
+   
+   
+        def paintCodeFolders(cursor):
+            y = self.cursorRect(cursor).top() 
+            h = self.cursorRect(cursor).height()
+            rect = QtCore.QRect(margin, y, h, h)
+            text = cursor.block().text()           
+            if text.rstrip().endswith(':'):
+                painter.drawRect(rect)
+                painter.drawText(rect, QtCore.Qt.AlignVCenter | QtCore.Qt.AlignHCenter, "-")
+                # Apply pen
+                
+                # Paint
+                #painter.drawLine(QtCore.QLine(margin, y, w - 2*margin, y))            
+            
+        self.doForVisibleBlocks(paintCodeFolders)
+        
+        painter.end()
+        
+
+
+class LongLineIndicator(object):
+    
+    # Register style element
+    _styleElements = [  (   'Editor.Long line indicator',
+                            'The color and style of the long line indicator.',
+                            'fore:#BBB,linestyle:solid', 
+                        ) ]
+    
+    def longLineIndicatorPosition(self):
+        """ longLineIndicatorPosition()
+        
+        Get the position of the long line indicator (aka edge column).
+        A value of 0 or smaller means that no indicator is shown.
+        
+        """
+        return self.__longLineIndicatorPosition
+    
+    @ce_option(80)
+    def setLongLineIndicatorPosition(self, value):
+        """ setLongLineIndicatorPosition(value)
+        
+        Set the position of the long line indicator (aka edge column).
+        A value of 0 or smaller means that no indicator is shown.
+        
+        """ 
+        self.__longLineIndicatorPosition = int(value)
+        self.viewport().update()
+    
+    
+    def paintEvent(self, event):    
+        """ paintEvent(event)
+        
+        Paint the long line indicator. Paints behind its super()
+        """    
+        if self.longLineIndicatorPosition()<=0:
+            super(LongLineIndicator, self).paintEvent(event)
+            return
+            
+        # Get doc and viewport
+        doc = self.document()
+        viewport = self.viewport()
+
+        # Get position of long line
+        fm = self.fontMetrics()
+        # width of ('i'*length) not length * (width of 'i') b/c of
+        # font kerning and rounding
+        x = fm.width('i' * self.longLineIndicatorPosition())
+        x += doc.documentMargin() + self.contentOffset().x()
+        x += 1 # Move it a little next to the cursor
+        
+        # Prepate painter
+        painter = QtGui.QPainter()
+        painter.begin(viewport)
+        
+        # Prepare pen
+        format = self.getStyleElementFormat('editor.LongLineIndicator')
+        pen = QtGui.QPen(format.fore)
+        pen.setStyle(format.linestyle)
+        painter.setPen(pen)
+        
+        # Draw line and end painter
+        painter.drawLine(QtCore.QLine(x, 0, x, viewport.height()) )
+        painter.end()
+        
+        # Propagate event
+        super(LongLineIndicator, self).paintEvent(event)
+
+
+
+
+class ShowWhitespace(object):
+    
+    def showWhitespace(self):
+        """Show or hide whitespace markers"""
+        option=self.document().defaultTextOption()
+        return bool(option.flags() & option.ShowTabsAndSpaces)
+    
+    @ce_option(False)
+    def setShowWhitespace(self,value):
+        option=self.document().defaultTextOption()
+        if value:
+            option.setFlags(option.flags() | option.ShowTabsAndSpaces)
+        else:
+            option.setFlags(option.flags() & ~option.ShowTabsAndSpaces)
+        self.document().setDefaultTextOption(option)
+
+
+class ShowLineEndings(object):
+    
+    @ce_option(False)
+    def showLineEndings(self):
+        """ Get whether line ending markers are shown. 
+        """
+        option=self.document().defaultTextOption()
+        return bool(option.flags() & option.ShowLineAndParagraphSeparators)
+    
+    
+    def setShowLineEndings(self,value):
+        option=self.document().defaultTextOption()
+        if value:
+            option.setFlags(option.flags() | option.ShowLineAndParagraphSeparators)
+        else:
+            option.setFlags(option.flags() & ~option.ShowLineAndParagraphSeparators)
+        self.document().setDefaultTextOption(option)
+
+
+
+class LineNumbers(object):
+    
+    # Margin on both side of the line numbers
+    _LineNumberAreaMargin = 3
+    
+    # Register style element
+    _styleElements = [  (   'Editor.Line numbers',
+                            'The text- and background-color of the line numbers.',
+                            'fore:#222,back:#DDD', 
+                        ) ]
+    
+    class __LineNumberArea(QtGui.QWidget):
+        """ This is the widget reponsible for drawing the line numbers.
+        """
+        
+        def __init__(self, codeEditor):
+            QtGui.QWidget.__init__(self, codeEditor)
+            self.setCursor(QtCore.Qt.PointingHandCursor)
+            self._pressedY = None
+            self._lineNrChoser = None
+        
+        def _getY(self, pos):
+            tmp = self.mapToGlobal(pos)
+            return self.parent().viewport().mapFromGlobal(tmp).y()
+        
+        def mousePressEvent(self, event):
+            self._pressedY = self._getY(event.pos())
+        
+        def mouseReleaseEvent(self, event):
+            self._handleWholeBlockSelection( self._getY(event.pos()) )
+        
+        def mouseMoveEvent(self, event):
+            self._handleWholeBlockSelection( self._getY(event.pos()) )
+            
+        def _handleWholeBlockSelection(self, y2):
+            # Get y1 and sort (y1, y2)
+            y1 = self._pressedY
+            if y1 is None: y1 = y2
+            y1, y2 = min(y1, y2), max(y1, y2)
+            
+            # Get cursor and two cursors corresponding to selected blocks
+            editor = self.parent()
+            cursor = editor.textCursor()
+            c1 = editor.cursorForPosition(QtCore.QPoint(0,y1))
+            c2 = editor.cursorForPosition(QtCore.QPoint(0,y2))
+            
+            # Make these two cursors select the whole block
+            c1.movePosition(c1.StartOfBlock, c1.MoveAnchor)
+            c2.movePosition(c2.EndOfBlock, c2.MoveAnchor)
+            
+            # Apply selection
+            cursor.setPosition(c1.position(), cursor.MoveAnchor)
+            cursor.setPosition(c2.position(), cursor.KeepAnchor)
+            editor.setTextCursor(cursor)
+        
+        def mouseDoubleClickEvent(self, event):
+            self.showLineNumberChoser()
+        
+        def showLineNumberChoser(self):
+            # Create line number choser if needed
+            if self._lineNrChoser is None:
+                self._lineNrChoser = LineNumbers.LineNumberChoser(self.parent())
+            # Get editor and cursor
+            editor = self.parent()
+            cursor = editor.textCursor()
+            # Get (x,y) pos and apply
+            x, y = self.width()+4, editor.cursorRect(cursor).y()
+            self._lineNrChoser.move(QtCore.QPoint(x,y))
+            # Show/reset line number choser
+            self._lineNrChoser.reset(cursor.blockNumber()+1)
+        
+        def paintEvent(self, event):
+            editor = self.parent()
+            
+            if not editor.showLineNumbers():
+                return
+            
+            # Get doc and viewport
+            doc = editor.document()
+            viewport = editor.viewport()
+            
+            # Get format and margin
+            format = editor.getStyleElementFormat('editor.LineNumbers')
+            margin = editor._LineNumberAreaMargin
+            
+            # Init painter
+            painter = QtGui.QPainter()
+            painter.begin(self)
+            
+            # Get which part to paint. Just do all to avoid glitches
+            w = editor.getLineNumberAreaWidth()
+            y1, y2 = 0, editor.height()
+            #y1, y2 = event.rect().top()-10, event.rect().bottom()+10
+    
+            # Get offset        
+            tmp = self.mapToGlobal(QtCore.QPoint(0,0))
+            offset = viewport.mapFromGlobal(tmp).y()
+            
+            #Draw the background        
+            painter.fillRect(QtCore.QRect(0, y1, w, y2), format.back)
+            
+            # Get cursor
+            cursor = editor.cursorForPosition(QtCore.QPoint(0,y1))
+            
+            # Prepare fonts
+            font1 = editor.font()
+            font2 = editor.font()
+            font2.setBold(True)
+            currentBlockNumber = editor.textCursor().block().blockNumber()
+            
+            # Init painter with font and color
+            painter.setFont(font1)
+            painter.setPen(format.fore)
+            
+            #Repainting always starts at the first block in the viewport,
+            #regardless of the event.rect().y(). Just to keep it simple
+            while True:
+                blockNumber = cursor.block().blockNumber()
+                
+                y = editor.cursorRect(cursor).y()
+                
+                # Set font to bold if line number is the current
+                if blockNumber == currentBlockNumber:
+                    painter.setFont(font2)
+                
+                painter.drawText(0, y-offset, w-margin, 50,
+                    Qt.AlignRight, str(blockNumber+1))
+                
+                # Set font back
+                if blockNumber == currentBlockNumber:
+                    painter.setFont(font1)
+                
+                if y>y2:
+                    break #Reached end of the repaint area
+                if not cursor.block().next().isValid():
+                    break #Reached end of the text
+                
+                cursor.movePosition(cursor.NextBlock)
+            
+            # Done
+            painter.end()
+    
+    class LineNumberChoser(QtGui.QSpinBox):
+        def __init__(self, parent):
+            QtGui.QSpinBox.__init__(self, parent)
+            
+            self._editor = parent
+            
+            ss = "QSpinBox { border: 2px solid #789; border-radius: 3px; padding: 4px; }"
+            self.setStyleSheet(ss)
+            
+            self.setPrefix('Go to line: ')
+            self.setAccelerated (True)
+            self.setButtonSymbols(self.NoButtons)
+            self.setCorrectionMode(self.CorrectToNearestValue)
+            
+            # Signal for when value changes, and flag to disbale it once
+            self._ignoreSignalOnceFlag = False
+            self.valueChanged.connect(self.onValueChanged)
+        
+        def reset(self, currentLineNumber):
+            # Set value to (given) current line number
+            self._ignoreSignalOnceFlag = True
+            self.setRange(1, self._editor.blockCount())
+            self.setValue(currentLineNumber)
+            # Select text and focus so that the user can simply start typing
+            self.selectAll()
+            self.setFocus()
+            # Make visible
+            self.show()
+            self.raise_()
+        
+        def focusOutEvent(self, event):
+            self.hide()
+        
+        def keyPressEvent(self, event):
+            if event.key() in [QtCore.Qt.Key_Escape, QtCore.Qt.Key_Enter, QtCore.Qt.Key_Return]:
+                self._editor.setFocus() # Moves focus away, thus hiding self
+            else:
+                QtGui.QSpinBox.keyPressEvent(self, event)
+        
+        def onValueChanged(self, nr):
+            if self._ignoreSignalOnceFlag:
+                self._ignoreSignalOnceFlag = False
+            else:
+                self._editor.gotoLine(nr)
+    
+    def __init__(self, *args, **kwds):
+        self.__lineNumberArea = None
+        super(LineNumbers, self).__init__(*args, **kwds)
+        # Create widget that draws the line numbers
+        self.__lineNumberArea = self.__LineNumberArea(self)
+        # Issue an update when the font or amount of line numbers changes
+        self.blockCountChanged.connect(self.__onBlockCountChanged)
+        self.fontChanged.connect(self.__onBlockCountChanged)
+        self.__onBlockCountChanged()
+        self.addLeftMargin(LineNumbers, self.getLineNumberAreaWidth)
+    
+    
+    def gotoLinePopup(self):
+        """ Popup the little widget to quickly goto a certain line.
+        Can also be achieved by double-clicking the line number area.
+        """
+        self.__lineNumberArea.showLineNumberChoser()
+    
+    def showLineNumbers(self):
+        return self.__showLineNumbers
+    
+    @ce_option(True)
+    def setShowLineNumbers(self, value):
+        self.__showLineNumbers = bool(value)
+        # Note that this method is called before the __init__ is finished,
+        # so that the __lineNumberArea is not yet created.
+        if self.__lineNumberArea:
+            if self.__showLineNumbers:
+                self.__onBlockCountChanged()
+                self.__lineNumberArea.show()
+            else:
+                self.__lineNumberArea.hide()
+            self.updateMargins()
+    
+    
+    def getLineNumberAreaWidth(self):
+        """
+        Count the number of lines, compute the length of the longest line number
+        (in pixels)
+        """
+        if not self.__showLineNumbers:
+            return 0
+        lastLineNumber = self.blockCount() 
+        margin = self._LineNumberAreaMargin
+        return self.fontMetrics().width(str(lastLineNumber)) + 2*margin
+    
+    
+    def __onBlockCountChanged(self,count=None):
+        """
+        Update the line number area width. This requires to set the 
+        viewport margins, so there is space to draw the linenumber area
+        """
+        if self.__showLineNumbers:
+            self.updateMargins()
+    
+    
+    def resizeEvent(self,event):
+        super(LineNumbers, self).resizeEvent(event)
+        
+        #On resize, resize the lineNumberArea, too
+        rect=self.contentsRect()
+        m = self.getLeftMargin(LineNumbers)
+        w = self.getLineNumberAreaWidth()
+        self.__lineNumberArea.setGeometry(  rect.x()+m, rect.y(),
+                                            w, rect.height())
+    
+    def paintEvent(self,event):
+        super(LineNumbers, self).paintEvent(event)
+        #On repaint, update the complete line number area
+        w = self.getLineNumberAreaWidth()
+        self.__lineNumberArea.update(0, 0, w, self.height() )
+
+
+
+class BreakPoints(object):
+    
+    _breakPointWidth = 11  # With of total bar, actual points are smaller
+    
+    # Register style element
+    _styleElements = [  (   'Editor.BreakPoints',
+                            'The fore- and background-color of the breakpoints.',
+                            'fore:#F66,back:#EEE', 
+                        ) ]
+    
+    class __BreakPointArea(QtGui.QWidget):
+        """ This is the widget reponsible for drawing the break points.
+        """
+        
+        def __init__(self, codeEditor):
+            QtGui.QWidget.__init__(self, codeEditor)
+            self.setCursor(QtCore.Qt.PointingHandCursor)
+        
+        def _getY(self, pos):
+            tmp = self.mapToGlobal(pos)
+            return self.parent().viewport().mapFromGlobal(tmp).y()
+        
+        def mousePressEvent(self, event):
+            self._toggleBreakPoint( self._getY(event.pos()))
+        
+        def _toggleBreakPoint(self, y):
+            # Get breakpoint corresponding to pressed pos
+            editor = self.parent()
+            cursor = editor.textCursor()
+            c1 = editor.cursorForPosition(QtCore.QPoint(0,y))
+            linenr = c1.blockNumber() + 1
+            
+            # Toggle
+            bps = self.parent()._breakPoints
+            if linenr in bps:
+                bps.discard(linenr)
+            else:
+                bps.add(linenr)
+            
+            # Emit signal
+            editor.breakPointsChanged.emit(editor)
+            self.update()
+        
+        def paintEvent(self, event):
+            editor = self.parent()
+            
+            if not editor.showBreakPoints():
+                return
+            
+            # Get doc and viewport
+            doc = editor.document()
+            viewport = editor.viewport()
+            
+            # Get format and margin
+            format = editor.getStyleElementFormat('editor.breakpoints')
+            margin = 1
+            w = editor._breakPointWidth
+            bulletWidth = w - 2*margin
+            
+            # Init painter
+            painter = QtGui.QPainter()
+            painter.begin(self)
+            
+            # Get which part to paint. Just do all to avoid glitches
+            y1, y2 = 0, editor.height()
+            
+            # Get offset        
+            tmp = self.mapToGlobal(QtCore.QPoint(0,0))
+            offset = viewport.mapFromGlobal(tmp).y()
+            
+            #Draw the background        
+            painter.fillRect(QtCore.QRect(0, y1, w, y2), format.back)
+            
+            # Get debug indicator and list of sorted breakpoints
+            debugBlockIndicator = editor._debugLineIndicator-1
+            blocknumbers = [i-1 for i in sorted(self.parent()._breakPoints)]
+            if not (blocknumbers or debugBlockIndicator > 0):
+                return
+            if not blocknumbers:  blocknumbers.append(-1)  # Safes a test below
+            
+            # Get cursor
+            cursor = editor.cursorForPosition(QtCore.QPoint(0,y1))
+            
+            # Init painter with font and color
+            painter.setPen(QtGui.QColor('#777'))
+            painter.setBrush(format.fore)
+            painter.setRenderHint(painter.Antialiasing)
+            
+            
+            #Repainting always starts at the first block in the viewport,
+            #regardless of the event.rect().y(). Just to keep it simple
+            while True:
+                blockNumber = cursor.block().blockNumber()
+                
+                # Done?
+                if blockNumber > blocknumbers[-1] and blockNumber > debugBlockIndicator:
+                    break
+                if not cursor.block().next().isValid():
+                    break #Reached end of the text
+                
+                # Draw
+                if blockNumber in blocknumbers:
+                    y = editor.cursorRect(cursor).center().y()
+                    y -= bulletWidth * 0.5
+                    painter.drawEllipse(margin, y, bulletWidth, bulletWidth)
+                if blockNumber == debugBlockIndicator:
+                    y = editor.cursorRect(cursor).center().y()
+                    y -= bulletWidth * 0.25
+                    painter.setBrush(QtGui.QColor('#6F6'))
+                    #painter.drawRect(margin, y, bulletWidth, 0.5*bulletWidth)
+                    painter.drawEllipse(margin, y, bulletWidth, 0.5*bulletWidth)
+                    painter.setBrush(format.fore)
+                
+                cursor.movePosition(cursor.NextBlock)
+            
+            # Done
+            painter.end()
+    
+    
+    def __init__(self, *args, **kwds):
+        self.__breakPointArea = None
+        super(BreakPoints, self).__init__(*args, **kwds)
+        # Create widget that draws the breakpoints
+        self.__breakPointArea = self.__BreakPointArea(self)
+        self.addLeftMargin(BreakPoints, self.getBreakPointAreaWidth)
+        self._breakPoints = set()
+        self._debugLineIndicator = 0
+    
+    
+    def breakPoints(self):
+        """ A list of breakpoints for this editor.
+        """
+        return list(sorted(self._breakPoints))
+    
+    
+    def clearBreakPoints(self):
+        """ Remove all breakpoints for this editor.
+        """
+        self._breakPoints = set()
+        self.breakPointsChanged.emit(self)
+    
+    
+    def setDebugLineIndicator(self, linenr):
+        """ Set the debug line indicator to the given line number.
+        If None or 0, the indicator is hidden.
+        """
+        linenr = int(linenr or 0)
+        if linenr != self._debugLineIndicator:
+            self._debugLineIndicator = linenr
+            self.__breakPointArea.update()
+    
+    
+    def getBreakPointAreaWidth(self):
+        if not self.__showBreakPoints:
+            return 0
+        else:
+            return self._breakPointWidth
+    
+    
+    def showBreakPoints(self):
+        return self.__showBreakPoints
+    
+    @ce_option(True)
+    def setShowBreakPoints(self, value):
+        self.__showBreakPoints = bool(value)
+        # Note that this method is called before the __init__ is finished,
+        # so that the area is not yet created.
+        if self.__breakPointArea:
+            if self.__showBreakPoints:
+                self.__breakPointArea.show()
+            else:
+                self.__breakPointArea.hide()
+                self.clearBreakPoints()
+            self.updateMargins()
+    
+    
+    def resizeEvent(self,event):
+        super(BreakPoints, self).resizeEvent(event)
+        
+        #On resize, resize the breakpointArea, too
+        rect=self.contentsRect()
+        m = self.getLeftMargin(BreakPoints)
+        w = self.getBreakPointAreaWidth()
+        self.__breakPointArea.setGeometry(  rect.x()+m, rect.y(),
+                                            w, rect.height())
+    
+    def paintEvent(self,event):
+        super(BreakPoints, self).paintEvent(event)
+        #On repaint, update the complete breakPointArea
+        w = self.getBreakPointAreaWidth()
+        self.__breakPointArea.update(0, 0, w, self.height() )
+
+
+
+class Wrap(object):
+    
+    def wrap(self):
+        """Enable or disable wrapping"""
+        option=self.document().defaultTextOption()
+        return not bool(option.wrapMode() == option.NoWrap)
+    
+    @ce_option(True)
+    def setWrap(self,value):
+        option=self.document().defaultTextOption()
+        if value:
+            option.setWrapMode(option.WrapAtWordBoundaryOrAnywhere)
+        else:
+            option.setWrapMode(option.NoWrap)
+        self.document().setDefaultTextOption(option)
+
+
+# todo: move this bit to base class? 
+# This functionality embedded in the highlighter and even has a designated
+# subpackage. I feel that it should be a part of the base editor.
+# Note: if we do this, remove the hasattr call in the highlighter.
+class SyntaxHighlighting(object):
+    """ Notes on syntax highlighting.
+
+    The syntax highlighting/parsing is performed using three "components".
+    
+    The base component are the token instances. Each token simply represents
+    a row of characters in the text the belong to each-other and should
+    be styled in the same way. There is a token class for each particular
+    "thing" in the code, such as comments, strings, keywords, etc. Some
+    tokens are specific to a particular language.
+    
+    There is a function that produces a set of tokens, when given a line of
+    text and a state parameter. There is such a function for each language.
+    These "parsers" are defined in the parsers subpackage.
+    
+    And lastly, there is the Highlighter class, that applies the parser function
+    to obtain the set of tokens and using the names of these tokens applies
+    styling. The styling can be defined by giving a dict that maps token names
+    to style representations.
+    
+    """
+    
+    # Register all syntax style elements
+    _styleElements = Manager.getStyleElementDescriptionsForAllParsers() 
+    
+    def parser(self):
+        """ parser()
+        
+        Get the parser instance currently in use to parse the code for 
+        syntax highlighting and source structure. Can be None.
+        
+        """
+        try:
+            return self.__parser
+        except AttributeError:
+            return None
+    
+    
+    @ce_option(None)
+    def setParser(self, parserName=''):
+        """ setParser(parserName='')
+        
+        Set the current parser by giving the parser name.
+        
+        """
+        # Set parser
+        self.__parser = Manager.getParserByName(parserName)
+
+        # Restyle, use setStyle for lazy updating
+        self.setStyle()
+        
diff --git a/simso/gui/codeeditor/extensions/autocompletion.py b/simso/gui/codeeditor/extensions/autocompletion.py
new file mode 100644
index 0000000..f5de08d
--- /dev/null
+++ b/simso/gui/codeeditor/extensions/autocompletion.py
@@ -0,0 +1,286 @@
+# -*- coding: utf-8 -*-
+# Copyright (C) 2013, the codeeditor development team
+#
+# IEP is distributed under the terms of the (new) BSD License.
+# The full license can be found in 'license.txt'.
+
+"""
+Code editor extensions that provides autocompleter functionality
+"""
+
+
+from ..qt import QtGui,QtCore
+Qt = QtCore.Qt
+
+import keyword
+
+#TODO: use this CompletionListModel to style the completion suggestions (class names, method names, keywords etc)
+class CompletionListModel(QtGui.QStringListModel):
+    def data(self, index, role):
+        if role == Qt.ForegroundRole:
+            # data = str(QtGui.QStringListModel.data(self, index, QtCore.Qt.DisplayRole))
+            # return QtGui.QBrush(Qt.red)
+            return None
+        else:
+            return QtGui.QStringListModel.data(self, index, role)
+
+# todo: use keywords from the parser
+class AutoCompletion(object):
+    def __init__(self,*args, **kwds):
+        super(AutoCompletion, self).__init__(*args, **kwds)
+        # Autocompleter
+        self.__completerModel = QtGui.QStringListModel(keyword.kwlist)
+        self.__completer = QtGui.QCompleter(self)
+        self.__completer.setModel(self.__completerModel)
+        self.__completer.setCaseSensitivity(Qt.CaseInsensitive)
+        self.__completer.setWidget(self)
+        self.__completerNames = []
+        self.__recentCompletions = [] #List of recently selected completions
+        
+        # geometry
+        self.__popupSize = 300, 100
+        
+        # Text position corresponding to first charcter of the word being completed
+        self.__autocompleteStart = None
+        
+        self.__autocompleteDebug = False
+        
+        self.__autocompletionAcceptKeys = (Qt.Key_Tab,)
+        
+        #Connect signals
+        self.__highlightedCompletion = None
+        self.__completer.activated.connect(self.onAutoComplete)
+        self.__completer.highlighted.connect(self._setHighlightedCompletion)
+    
+    def _setHighlightedCompletion(self, value):
+        """ Keeping track of the highlighted item allows us
+        to 'manually' perform an autocompletion.
+        """
+        self.__highlightedCompletion = value
+    
+    ## Properties
+    def recentCompletionsList(self):
+        """ 
+        The list of recent auto-completions. This property may be set to a
+        list that is shared among several editors, in order to share the notion
+        of recent auto-completions
+        """
+        return self.__recentCompletions
+    
+    def setRecentCompletionsList(self,value):
+        self.__recentCompletions = value
+    
+    def completer(self):
+        return self.__completer
+        
+    
+    def setAutoCompletionAcceptKeys(self, *keys):
+        """ Set the keys that can accept an autocompletion.
+        Like Tab, or Enter. Defaut Tab.
+        """
+        self.__autocompletionAcceptKeys = keys
+    
+    
+    ## Autocompletion
+    
+    def setAutocompletPopupSize(self, width, height):
+        """
+        Set the size (width, heigth) of the automcompletion popup window.
+        """
+        self.__popupSize = width, height
+    
+    
+    def autocompleteShow(self,offset = 0,names = None):
+        """
+        Pop-up the autocompleter (if not already visible) and position it at current
+        cursor position minus offset. If names is given and not None, it is set
+        as the list of possible completions.
+        """
+        #Pop-up the autocompleteList
+        startcursor=self.textCursor()
+        startcursor.movePosition(startcursor.Left, n=offset)
+        
+        if self.__autocompleteDebug:
+            print('autocompleteShow called')
+        
+        if not self.autocompleteActive() or \
+            startcursor.position() != self.__autocompleteStart.position():
+
+            self.__autocompleteStart=startcursor
+            self.__autocompleteStart.setKeepPositionOnInsert(True)
+
+            #Popup the autocompleter. Don't use .complete() since we want to
+            #position the popup manually
+            self.__positionAutocompleter()
+            self.__updateAutocompleterPrefix()
+            self.__completer.popup().show()
+            
+            if self.__autocompleteDebug:
+                print('self.__completer.popup().show() called')
+        
+        if names is not None:
+            #TODO: a more intelligent implementation that adds new items and removes
+            #old ones
+            if names != self.__completerNames:
+                self.__completerModel.setStringList(names)
+                self.__completerNames = names
+        self.__updateAutocompleterPrefix()
+    
+    def autocompleteAccept(self):
+        pass
+    
+    def autocompleteCancel(self):
+        self.__completer.popup().hide()
+        self.__autocompleteStart = None
+        
+    def onAutoComplete(self, text=None):
+        if text is None:
+            text = self.__highlightedCompletion
+        #Select the text from autocompleteStart until the current cursor
+        cursor=self.textCursor()
+        cursor.setPosition(self.__autocompleteStart.position(),cursor.KeepAnchor)
+        #Replace it with the selected text 
+        cursor.insertText(text)
+        self.autocompleteCancel() #Reset the completer
+        
+        #Update the recent completions list
+        if text in self.__recentCompletions:
+            self.__recentCompletions.remove(text)
+        self.__recentCompletions.append(text)
+        
+    def autocompleteActive(self):
+        """ Returns whether an autocompletion list is currently shown. 
+        """
+        return self.__autocompleteStart is not None
+    
+    
+    def __positionAutocompleter(self):
+        """Move the autocompleter list to a proper position"""
+        #Find the start of the autocompletion and move the completer popup there
+        cur=QtGui.QTextCursor(self.__autocompleteStart) #Copy __autocompleteStart
+        
+        # Set size
+        geometry = self.__completer.popup().geometry()
+        geometry.setWidth(self.__popupSize[0])
+        geometry.setHeight(self.__popupSize[1])
+        self.__completer.popup().setGeometry(geometry)
+        
+        # Initial choice for position of the completer
+        position = self.cursorRect(cur).bottomLeft() + self.viewport().pos()
+        
+        # Check if the completer is going to go off the screen
+        desktop_geometry = QtGui.qApp.desktop().geometry()
+        global_position = self.mapToGlobal(position)
+        if global_position.y() + geometry.height() > desktop_geometry.height():
+            # Move the completer to above the current line
+            position = self.cursorRect(cur).topLeft() + self.viewport().pos()
+            global_position = self.mapToGlobal(position)
+            global_position -= QtCore.QPoint(0, geometry.height())
+        
+        self.__completer.popup().move(global_position)
+    
+    
+    def __updateAutocompleterPrefix(self):
+        """
+        Find the autocompletion prefix (the part of the word that has been 
+        entered) and send it to the completer. Update the selected completion
+        (out of several possiblilties) which is best suited
+        """
+        if not self.autocompleteActive():
+            self.__completer.popup().hide() #TODO: why is this required?
+            return
+        
+        #Select the text from autocompleteStart until the current cursor
+        cursor=self.textCursor()
+        cursor.setPosition(self.__autocompleteStart.position(),cursor.KeepAnchor)
+        
+        prefix=cursor.selectedText()
+        self.__completer.setCompletionPrefix(prefix)
+        model = self.__completer.completionModel()
+        if model.rowCount():
+            # Create a list of all possible completions, and select the one
+            # which is best suited. Use the one which is highest in the
+            # __recentCompletions list, but prefer completions with matching
+            # case if they exists
+            
+            # Create a list of (row, value) tuples of all possible completions
+            completions = [
+                (row, model.data(model.index(row,0),self.__completer.completionRole()))
+                for row in range(model.rowCount())
+                ]
+            
+            # Define a function to get the position in the __recentCompletions
+            def completionIndex(data):
+                try:
+                    return self.__recentCompletions.index(data)
+                except ValueError:
+                    return -1
+            
+            # Sort twice; the last sort has priority over the first
+            
+            # Sort on most recent completions
+            completions.sort(key = lambda c: completionIndex(c[1]), reverse = True)
+            # Sort on matching case (prefer matching case)
+            completions.sort(key = lambda c: c[1].startswith(prefix), reverse = True)
+
+            # apply the best match
+            bestMatchRow = completions[0][0]
+            self.__completer.popup().setCurrentIndex(model.index(bestMatchRow, 0))
+
+                
+        else:
+            #No match, just hide
+            self.autocompleteCancel()
+    
+    
+    def potentiallyAutoComplete(self, event):
+        """ potentiallyAutoComplete(event)
+        Given a keyEvent, check if we should perform an autocompletion.
+        Returns 0 if no autocompletion was performed. Return 1 if
+        autocompletion was performed, but the key event should be processed
+        as normal. Return 2 if the autocompletion was performed, and the key
+        should be consumed.
+        """
+        if self.autocompleteActive():
+            if event.key() in self.__autocompletionAcceptKeys:
+                if event.key() <= 128:
+                    self.onAutoComplete()  # No arg: select last highlighted
+                    self.autocompleteCancel()
+                    event.ignore()
+                    return 1  # Let key have effect as normal
+                elif event.modifiers() == Qt.NoModifier:
+                    # The key 
+                    self.onAutoComplete()  # No arg: select last highlighted
+                    self.autocompleteCancel()
+                    return 2  # Key should be consumed
+        return 0
+    
+    
+    def keyPressEvent(self, event):
+        key = event.key()
+        modifiers = event.modifiers()
+        if key == Qt.Key_Escape and modifiers == Qt.NoModifier and \
+                self.autocompleteActive():
+            self.autocompleteCancel()
+            return #Consume the key
+        
+        if self.potentiallyAutoComplete(event) > 1:
+            return  #Consume
+        
+        #Allowed keys that do not close the autocompleteList:
+        # alphanumeric and _ ans shift
+        # Backspace (until start of autocomplete word)
+        if self.autocompleteActive() and \
+            not event.text().isalnum() and event.text() != '_' and \
+            key != Qt.Key_Shift and not (
+            (key==Qt.Key_Backspace) and self.textCursor().position()>self.__autocompleteStart.position()):
+            self.autocompleteCancel()
+        
+        # Apply the key that was pressed
+        super(AutoCompletion, self).keyPressEvent(event)
+        
+        if self.autocompleteActive():
+            #While we type, the start of the autocompletion may move due to line
+            #wrapping, so reposition after every key stroke
+            self.__positionAutocompleter()
+            self.__updateAutocompleterPrefix()
diff --git a/simso/gui/codeeditor/extensions/behaviour.py b/simso/gui/codeeditor/extensions/behaviour.py
new file mode 100644
index 0000000..cc541ab
--- /dev/null
+++ b/simso/gui/codeeditor/extensions/behaviour.py
@@ -0,0 +1,209 @@
+# -*- coding: utf-8 -*-
+# Copyright (C) 2013, the codeeditor development team
+#
+# IEP is distributed under the terms of the (new) BSD License.
+# The full license can be found in 'license.txt'.
+
+"""
+Code editor extensions that change its behaviour (i.e. how it reacts to keys)
+"""
+
+
+from ..qt import QtGui,QtCore
+Qt = QtCore.Qt
+
+from ..misc import ustr, ce_option
+from ..parsers.tokens import (CommentToken,UnterminatedStringToken)
+from ..parsers import BlockState
+
+class HomeKey(object):
+    
+    def keyPressEvent(self,event):
+        # Home or shift + home
+        if event.key() == Qt.Key_Home and \
+                event.modifiers() in (Qt.NoModifier, Qt.ShiftModifier):
+            # Prepare
+            cursor = self.textCursor()
+            shiftDown = event.modifiers() == Qt.ShiftModifier
+            moveMode = [cursor.MoveAnchor, cursor.KeepAnchor][shiftDown]
+            # Get leading whitespace
+            text = ustr(cursor.block().text())
+            leadingWhitespace = text[:len(text)-len(text.lstrip())]
+            # Get current position and move to start of whitespace
+            i = cursor.positionInBlock()
+            cursor.movePosition(cursor.StartOfBlock, moveMode)
+            cursor.movePosition(cursor.Right, moveMode, len(leadingWhitespace))
+            # If we were alread there, move to start of block
+            if cursor.positionInBlock() == i:
+                cursor.movePosition(cursor.StartOfBlock, moveMode)
+            # Done
+            self.setTextCursor(cursor)
+        else:
+            super(HomeKey, self).keyPressEvent(event)
+
+class EndKey(object):
+    
+    def keyPressEvent(self,event):
+        if event.key() == Qt.Key_End and \
+                event.modifiers() in (Qt.NoModifier, Qt.ShiftModifier):
+            # Prepare
+            cursor = self.textCursor()
+            shiftDown = event.modifiers() == Qt.ShiftModifier
+            moveMode = [cursor.MoveAnchor, cursor.KeepAnchor][shiftDown]
+            # Get current position and move to end of line
+            i = cursor.positionInBlock()
+            cursor.movePosition(cursor.EndOfLine, moveMode)
+            # If alread at end of line, move to end of block
+            if cursor.positionInBlock() == i:
+                cursor.movePosition(cursor.EndOfBlock, moveMode)
+            # Done
+            self.setTextCursor(cursor)
+        else:
+            super(EndKey, self).keyPressEvent(event)
+
+class NumpadPeriodKey(object):
+    """
+    If the numpad decimal separator key is pressed, always insert
+    a period (.) even if due to localization that key is mapped to a
+    comma (,). When editing code, period is the decimal separator
+    independent of localization
+    """
+    def keyPressEvent(self,event):
+        # Check for numpad comma
+        if event.key() == QtCore.Qt.Key_Comma and \
+                event.modifiers() & QtCore.Qt.KeypadModifier:
+                    
+            # Create a new QKeyEvent to substitute the original one
+            event = QtGui.QKeyEvent(event.type(), QtCore.Qt.Key_Period,
+                event.modifiers(), '.', event.isAutoRepeat(), event.count())
+            
+        super(NumpadPeriodKey, self).keyPressEvent(event)
+
+
+class Indentation(object):
+    
+    def __cursorIsInLeadingWhitespace(self,cursor = None):
+        """
+        Checks wether the given cursor is in the leading whitespace of a block, i.e.
+        before the first non-whitespace character. The cursor is not modified.
+        If the cursor is not given or is None, the current textCursor is used
+        """
+        if cursor is None:
+            cursor = self.textCursor()
+        
+        # Get the text of the current block up to the cursor
+        textBeforeCursor = ustr(cursor.block().text())[:cursor.positionInBlock()]
+        return textBeforeCursor.lstrip() == '' #If we trim it and it is empty, it's all whitespace
+    
+    def keyPressEvent(self,event):
+        key = event.key()
+        modifiers = event.modifiers()
+        #Tab key
+        if key == Qt.Key_Tab:
+            if modifiers == Qt.NoModifier:
+                if self.textCursor().hasSelection(): #Tab pressed while some area was selected
+                    self.indentSelection()
+                    return
+                elif self.__cursorIsInLeadingWhitespace():
+                    #If the cursor is in the leading whitespace, indent and move cursor to end of whitespace
+                    cursor = self.textCursor()
+                    self.indentBlock(cursor)
+                    self.setTextCursor(cursor)
+                    return
+                    
+                elif self.indentUsingSpaces():
+                    #Insert space-tabs
+                    cursor=self.textCursor()
+                    w = self.indentWidth()
+                    cursor.insertText(' '*(w-((cursor.positionInBlock() + w ) % w)))
+                    return
+                #else: default behaviour, insert tab character
+            else: #Some other modifiers + Tab: ignore
+                return
+
+        # If backspace is pressed in the leading whitespace, (except for at the first 
+        # position of the line), and there is no selection
+        # dedent that line and move cursor to end of whitespace
+        if key == Qt.Key_Backspace and modifiers == Qt.NoModifier and \
+                self.__cursorIsInLeadingWhitespace() and not self.textCursor().atBlockStart() \
+                and not self.textCursor().hasSelection():
+            # Create a cursor, dedent the block and move screen cursor to the end of the whitespace
+            cursor = self.textCursor()
+            self.dedentBlock(cursor)
+            self.setTextCursor(cursor)
+            return
+        
+        # todo: Same for delete, I think not (what to do with the cursor?)
+        
+        # Auto-unindent
+        if event.key() == Qt.Key_Delete:
+            cursor = self.textCursor()
+            if not cursor.hasSelection():
+                cursor.movePosition(cursor.EndOfBlock, cursor.KeepAnchor)
+                if not cursor.hasSelection() and cursor.block().next().isValid():
+                    cursor.beginEditBlock()
+                    cursor.movePosition(cursor.NextBlock)
+                    self.indentBlock(cursor, -99)  # dedent as much as we can
+                    cursor.deletePreviousChar()
+                    cursor.endEditBlock()
+                    return
+        
+        super(Indentation, self).keyPressEvent(event)
+        
+class AutoIndent(object):
+    """
+    Auto indentation. This extension only adds the autoIndent property, for the
+    actual indentation, the editor should derive from some AutoIndenter object
+    """
+    
+    def autoIndent(self):
+        """ autoIndent()
+        
+        Get whether auto indentation is enabled.
+        
+        """
+        return self.__autoIndent
+    
+    @ce_option(True)
+    def setAutoIndent(self,value):
+        """ setAutoIndent(value)
+        
+        Set whether to enable auto indentation.  
+        
+        """
+        self.__autoIndent = bool(value)
+        
+        
+class PythonAutoIndent(object):
+    
+    def keyPressEvent(self,event):
+        super(PythonAutoIndent, self).keyPressEvent(event)
+        if not self.autoIndent():
+            return
+        
+        #This extension code is run *after* key is processed by QPlainTextEdit
+        
+        if event.key() in (Qt.Key_Enter,Qt.Key_Return):
+            cursor=self.textCursor()
+            previousBlock=cursor.block().previous()
+            if previousBlock.isValid():
+                line = ustr(previousBlock.text())
+                indent=line[:len(line)-len(line.lstrip())]
+                if line.endswith(':'): 
+                    # We only need to add indent if the : is not in a (multiline)
+                    # string or comment. Therefore, find out what the syntax
+                    # highlighter thinks of the previous line.
+                    ppreviousBlock = previousBlock.previous() # the block before previous
+                    ppreviousState = ppreviousBlock.userState() if previousBlock.isValid() else 0
+                    lastElementToken = list(self.parser().parseLine(previousBlock.text(),ppreviousState))[-1]
+                        # Because there's at least a : on that line, the list is never empty
+                    
+                    if (not isinstance(lastElementToken, (CommentToken, UnterminatedStringToken, BlockState))):
+                        #TODO: check correct identation (no mixed space/tabs)
+                        if self.indentUsingSpaces():
+                            indent+=' '*self.indentWidth()
+                        else:
+                            indent+='\t'
+                cursor.insertText(indent)
+                #This prevents jump to start of line when up key is pressed
+                self.setTextCursor(cursor)
diff --git a/simso/gui/codeeditor/extensions/calltip.py b/simso/gui/codeeditor/extensions/calltip.py
new file mode 100644
index 0000000..61b7970
--- /dev/null
+++ b/simso/gui/codeeditor/extensions/calltip.py
@@ -0,0 +1,137 @@
+# -*- coding: utf-8 -*-
+# Copyright (C) 2013, the codeeditor development team
+#
+# IEP is distributed under the terms of the (new) BSD License.
+# The full license can be found in 'license.txt'.
+
+from ..qt import QtCore, QtGui
+Qt = QtCore.Qt
+
+class Calltip(object):
+    _styleElements = [('Editor.calltip', 'The style of the calltip. ',
+                        'fore:#555, back:#ff9, border:1')]
+    
+    class __CalltipLabel(QtGui.QLabel):
+        def __init__(self):
+            QtGui.QLabel.__init__(self)
+            
+            # Start hidden
+            self.hide()
+            # Accept rich text
+            self.setTextFormat(QtCore.Qt.RichText)
+            # Show as tooltip
+            self.setIndent(2)
+            self.setWindowFlags(QtCore.Qt.ToolTip)
+        
+        def enterEvent(self, event):
+            # Act a bit like a tooltip
+            self.hide()
+    
+    
+    def __init__(self, *args, **kwds):
+        super(Calltip, self).__init__(*args, **kwds)
+        # Create label for call tips
+        self.__calltipLabel = self.__CalltipLabel()
+        # Be notified of style updates
+        self.styleChanged.connect(self.__afterSetStyle)
+        
+        # Prevents calltips from being shown immediately after pressing
+        # the escape key.
+        self.__noshow = False
+    
+    
+    def __afterSetStyle(self):
+        format = self.getStyleElementFormat('editor.calltip')
+        ss = "QLabel { color:%s; background:%s; border:%ipx solid %s; }" % (
+                    format['fore'], format['back'], 
+                    int(format['border']), format['fore'] )
+        self.__calltipLabel.setStyleSheet(ss)
+    
+    
+    def calltipShow(self, offset=0, richText='', highlightFunctionName=False):
+        """ calltipShow(offset=0, richText='', highlightFunctionName=False)
+        
+        Shows the given calltip.
+        
+        Parameters
+        ----------
+        offset : int
+            The character offset to show the tooltip.
+        richText : str
+            The text to show (may contain basic html for markup).
+        highlightFunctionName : bool
+            If True the text before the first opening brace is made bold.
+            default False.
+        
+        """
+        
+        # Do not show the calltip if it was deliberately hidden by the
+        # user.
+        if self.__noshow:
+            return
+        
+        # Process calltip text?
+        if highlightFunctionName:
+            i = richText.find('(')
+            if i>0:
+                richText = '<b>{}</b>{}'.format(richText[:i], richText[i:])
+        
+        # Get a cursor to establish the position to show the calltip
+        startcursor = self.textCursor()
+        startcursor.movePosition(startcursor.Left, n=offset)
+        
+        # Get position in pixel coordinates
+        rect = self.cursorRect(startcursor)
+        pos = rect.topLeft()
+        pos.setY( pos.y() - rect.height() - 1 ) # Move one above line
+        pos.setX( pos.x() - 3) # Correct for border and indent
+        pos = self.viewport().mapToGlobal(pos)
+        
+        # Set text and update font
+        self.__calltipLabel.setText(richText)
+        self.__calltipLabel.setFont(self.font())
+        
+        # Use a qt tooltip to show the calltip
+        if richText:
+            self.__calltipLabel.move(pos)
+            self.__calltipLabel.show()
+        else:
+            self.__calltipLabel.hide()
+    
+    
+    def calltipCancel(self):
+        """ calltipCancel()
+        
+        Hides the calltip.
+        
+        """
+        self.__calltipLabel.hide()
+    
+    
+    def calltipActive(self):
+        """ calltipActive()
+        
+        Get whether the calltip is currently active.
+        
+        """
+        return self.__calltipLabel.isVisible()
+    
+    
+    def focusOutEvent(self, event):
+        super(Calltip, self).focusOutEvent(event)
+        self.__calltipLabel.hide()
+    
+    
+    def keyPressEvent(self,event):
+        # If the user presses Escape and the calltip is active, hide it
+        if event.key() == Qt.Key_Escape and event.modifiers() == Qt.NoModifier \
+                and self.calltipActive():
+            self.calltipCancel()
+            self.__noshow = True
+            return
+        
+        if event.key() in [Qt.Key_ParenLeft, Qt.Key_ParenRight]:
+            self.__noshow = False
+        
+        # Proceed processing the keystrike
+        super(Calltip, self).keyPressEvent(event)
diff --git a/simso/gui/codeeditor/highlighter.py b/simso/gui/codeeditor/highlighter.py
new file mode 100644
index 0000000..3ce0654
--- /dev/null
+++ b/simso/gui/codeeditor/highlighter.py
@@ -0,0 +1,134 @@
+# -*- coding: utf-8 -*-
+# Copyright (C) 2013, the codeeditor development team
+#
+# IEP is distributed under the terms of the (new) BSD License.
+# The full license can be found in 'license.txt'.
+
+""" Module highlighter
+
+Defines the highlighter class for the base code editor class. It will do
+the styling when syntax highlighting is enabled. If it is not, will only 
+check out indentation.
+
+"""
+
+import time
+
+from .qt import QtGui, QtCore
+Qt = QtCore.Qt
+
+from . import parsers
+from .misc import ustr
+
+
+class BlockData(QtGui.QTextBlockUserData):
+    """ Class to represent the data for a block.
+    """
+    def __init__(self):
+        QtGui.QTextBlockUserData.__init__(self)
+        self.indentation = None
+        self.fullUnderlineFormat = None
+
+
+# The highlighter should be part of the base class, because 
+# some extensions rely on them (e.g. the indent guuides).
+class Highlighter(QtGui.QSyntaxHighlighter):
+    
+    def __init__(self,codeEditor,*args):
+        QtGui.QSyntaxHighlighter.__init__(self,*args)
+        
+        # Store reference to editor
+        self._codeEditor = codeEditor
+    
+    
+    def getCurrentBlockUserData(self):
+        """ getCurrentBlockUserData()
+        
+        Gets the BlockData object. Creates one if necesary.
+        
+        """
+        bd = self.currentBlockUserData()
+        if not isinstance(bd, BlockData):
+            bd = BlockData()
+            self.setCurrentBlockUserData(bd)
+        return bd
+    
+    
+    def highlightBlock(self, line): 
+        """ highlightBlock(line)
+        
+        This method is automatically called when a line must be 
+        re-highlighted.
+        
+        If the code editor has an active parser. This method will use
+        it to perform syntax highlighting. If not, it will only 
+        check out the indentation.
+        
+        """
+        
+        # Make sure this is a Unicode Python string
+        line = ustr(line)
+        
+        # Get previous state
+        previousState = self.previousBlockState()
+        
+        # Get parser
+        parser = None
+        if hasattr(self._codeEditor, 'parser'):
+            parser = self._codeEditor.parser()
+        
+        # Get function to get format
+        nameToFormat = self._codeEditor.getStyleElementFormat
+        
+        fullLineFormat = None
+        if parser:
+            self.setCurrentBlockState(0)
+            for token in parser.parseLine(line, previousState):
+                # Handle block state
+                if isinstance(token, parsers.BlockState):
+                    self.setCurrentBlockState(token.state)
+                else:
+                    # Get format
+                    try:
+                        styleFormat = nameToFormat(token.name)
+                        charFormat = styleFormat.textCharFormat
+                    except KeyError:
+                        #print(repr(nameToFormat(token.name)))
+                        continue
+                    # Set format
+                    self.setFormat(token.start,token.end-token.start,charFormat)
+                    # Is this a cell?
+                    if (fullLineFormat is None) and styleFormat._parts.get('underline','') == 'full':
+                        fullLineFormat = styleFormat
+        
+        # Get user data
+        bd = self.getCurrentBlockUserData()
+        
+        # Handle underlines
+        bd.fullUnderlineFormat = fullLineFormat
+        
+        # Get the indentation setting of the editors
+        indentUsingSpaces = self._codeEditor.indentUsingSpaces()
+        
+        leadingWhitespace=line[:len(line)-len(line.lstrip())]
+        if '\t' in leadingWhitespace and ' ' in leadingWhitespace:
+            #Mixed whitespace
+            bd.indentation = 0
+            format=QtGui.QTextCharFormat()
+            format.setUnderlineStyle(QtGui.QTextCharFormat.SpellCheckUnderline)
+            format.setUnderlineColor(QtCore.Qt.red)
+            format.setToolTip('Mixed tabs and spaces')
+            self.setFormat(0,len(leadingWhitespace),format)
+        elif ('\t' in leadingWhitespace and indentUsingSpaces) or \
+            (' ' in leadingWhitespace and not indentUsingSpaces):
+            #Whitespace differs from document setting
+            bd.indentation = 0
+            format=QtGui.QTextCharFormat()
+            format.setUnderlineStyle(QtGui.QTextCharFormat.SpellCheckUnderline)
+            format.setUnderlineColor(QtCore.Qt.blue)
+            format.setToolTip('Whitespace differs from document setting')
+            self.setFormat(0,len(leadingWhitespace),format)
+        else:
+            # Store info for indentation guides
+            # amount of tabs or spaces
+            bd.indentation = len(leadingWhitespace)
diff --git a/simso/gui/codeeditor/manager.py b/simso/gui/codeeditor/manager.py
new file mode 100644
index 0000000..a36e112
--- /dev/null
+++ b/simso/gui/codeeditor/manager.py
@@ -0,0 +1,292 @@
+# -*- coding: utf-8 -*-
+# Copyright (C) 2013, the codeeditor development team
+#
+# Codeeditor is distributed under the terms of the (new) BSD License.
+# The full license can be found in 'license.txt'.
+
+""" Module manager
+
+This module contains a static class that can be used for some
+management tasks.
+
+"""
+
+import os, sys
+
+from .qt import QtGui, QtCore
+Qt = QtCore.Qt
+
+from . import parsers
+
+
+class Manager:
+    """ Manager
+    
+    Static class to do some management tasks:
+      * It manages the parsers
+      * Getting style element descriptions of all parsers
+      * Linking file extensions to parsers
+      * Font information
+    
+    """
+    
+    _defaultFontFamily = 'dummy_font_family_name'
+    
+    # Static dict of all parsers
+    _parserInstances = {}
+    _fileExtensions = {}
+    
+    ## Parsers
+    
+#     @classmethod
+#     def collectParsersDynamically(cls):
+#         """ insert the function is this module's namespace.
+#         """
+#         
+#         # Get the path of this subpackage
+#         path = __file__
+#         path = os.path.dirname( os.path.abspath(path) )
+#         
+#         # Determine if we're in a zipfile
+#         i = path.find('.zip')
+#         if i>0:
+#             # get list of files from zipfile
+#             path = path[:i+4]
+#             z = zipfile.ZipFile(path)
+#             files = [os.path.split(i)[-1] for i in z.namelist() 
+#                         if 'codeeditor' in i and 'parsers' in i]
+#         else:
+#             # get list of files from file system
+#             files = os.listdir(path)
+#         
+#         # Extract all parsers
+#         parserModules = []
+#         for file in files:            
+#             
+#             # Only python files
+#             if file.endswith('.pyc'):
+#                 if file[:-1] in files:
+#                     continue # Only try import once
+#             elif not file.endswith('.py'):
+#                 continue    
+#             # Only syntax files
+#             if '_parser.' not in file:
+#                 continue
+#             
+#             # Import module
+#             fullfile = os.path.join(path, file)
+#             modname = os.path.splitext(file)[0]
+#             print('modname', modname)
+#             mod = __import__("codeeditor.parsers."+modname, fromlist=[modname])
+#             parserModules.append(mod)
+#         
+#         print(parserModules)
+    
+
+    
+    @classmethod
+    def _collectParsers(cls):
+        """ _collectParsers()
+        
+        Collect all parser classes. This function is called on startup.
+        
+        """
+        
+        # Prepare (use a set to prevent duplicates)
+        foundParsers = set()
+        G = parsers.__dict__
+        ModuleClass = os.__class__
+        
+        # Collect parser classes
+        for module_name in G:
+            # Check if it is indeed a module, and if it has the right name
+            if not isinstance(G[module_name], ModuleClass):
+                continue
+            if not module_name.endswith('_parser'):
+                continue
+            # Collect all valid classes from the module
+            moduleDict = G[module_name].__dict__
+            for name_in_module in moduleDict:
+                ob = moduleDict[name_in_module]                    
+                if isinstance(ob, type) and issubclass(ob, parsers.Parser):
+                    foundParsers.add(ob)
+        
+        # Put in list with the parser names as keys
+        parserInstances = {}
+        for parserClass in foundParsers:
+            name = parserClass.__name__
+            if name.endswith('Parser') and len(name)>6:
+                
+                # Get parser identifier name
+                name = name[:-6].lower()
+                
+                # Try instantiating the parser
+                try:
+                    parserInstances[name] = parserInstance = parserClass()
+                except Exception:
+                    # We cannot get the exception object in a Python2/Python3
+                    # compatible way
+                    print('Could not instantiate parser "%s".'%name)
+                    continue
+                
+                # Register extensions for this parser
+                for ext in parserInstance.filenameExtensions():
+                    cls._fileExtensions[ext] = name
+        
+        # Store
+        cls._parserInstances = parserInstances
+    
+    
+    @classmethod
+    def getParserNames(cls):
+        """ getParserNames()
+        
+        Get a list of all available parsers.
+        
+        """
+        return list(cls._parserInstances.keys())
+    
+    
+    @classmethod
+    def getParserByName(cls, parserName):
+        """ getParserByName(parserName)
+        
+        Get the parser object corresponding to the given name.
+        If no parser is known by the given name, a warning message
+        is printed and None is returned.
+        
+        """
+        if not parserName:
+            return parsers.Parser() #Default dummy parser
+            
+        # Case insensitive
+        parserName = parserName.lower()
+        
+        # Return instantiated parser object.
+        if parserName in cls._parserInstances:
+            return cls._parserInstances[parserName]
+        else:
+            print('Warning: no parser known by the name "%s".'%parserName)
+            print('I know these: ', cls._parserInstances.keys())
+            return parsers.Parser() #Default dummy parser
+    
+    
+    @classmethod
+    def getStyleElementDescriptionsForAllParsers(cls):
+        """ getStyleElementDescriptionsForAllParsers()
+        
+        Get all style element descriptions corresponding to 
+        the tokens of all parsers.
+        
+        This function is used by the code editor to register all syntax
+        element styles to the code editor class.
+        
+        """
+        descriptions = {}
+        for parser in cls._parserInstances.values():
+            for token in parser.getUsedTokens():
+                description = token.description
+                descriptions[description.key] = description
+        
+        return list(descriptions.values())
+    
+    
+    ## File extensions
+    
+    
+    @classmethod
+    def suggestParserfromFilenameExtension(cls, ext):
+        """ suggestParserfromFilenameExtension(ext)
+        
+        Given a filename extension, rerurns the name of the suggested
+        parser corresponding to the language of the file.
+        
+        See also registerFilenameExtension()
+        """
+        
+        # Normalize ext
+        ext = '.' + ext.lstrip('.').lower()
+        
+        # Get parser
+        if ext in cls._fileExtensions:
+            return cls._fileExtensions[ext]
+        else:
+            return ''
+    
+    
+    @classmethod
+    def registerFilenameExtension(cls, ext, parser):
+        """ registerFilenameExtension(ext, parser)
+        
+        Registers the given filename extension to the given parser.
+        The parser can be a Parser instance or its name.
+        
+        This function can be used to register extensions to parsers
+        that are not registered by default.
+        
+        """
+        # Normalize ext
+        ext = '.' + ext.lstrip('.').lower()
+        # Check parser
+        if isinstance(parser, parsers.Parser):
+            parser = parser.name()
+        # Register
+        cls._fileExtensions[ext] = parser
+    
+    
+    ## Fonts
+    
+    
+    @classmethod
+    def fontNames(cls):
+        """ fontNames()
+        
+        Get a list of all monospace fonts available on this system.
+        
+        """
+        db = QtGui.QFontDatabase()
+        QFont, QFontInfo = QtGui.QFont, QtGui.QFontInfo
+        # fn = font_name (str)
+        return [fn for fn in db.families() if QFontInfo(QFont(fn)).fixedPitch()]
+    
+    
+    @classmethod
+    def setDefaultFontFamily(cls, name):
+        """ setDefaultFontFamily(name)
+        
+        Set the default (monospace) font family name for this system. 
+        This should be set only once during startup.
+        
+        """
+        cls._defaultFontFamily = name
+    
+    
+    @classmethod
+    def defaultFont(cls):
+        """ defaultFont()
+        
+        Get the default (monospace) font for this system. Returns a QFont
+        object. 
+        
+        """
+    
+        # Get font size that makes sense for this system
+        f = QtGui.QFont()
+        size = f.pointSize()
+        
+        # Get font family 
+        f = QtGui.QFont(cls._defaultFontFamily)
+        f.setStyleHint(f.TypeWriter, f.PreferDefault)
+        fi = QtGui.QFontInfo(f)
+        family = fi.family()
+        
+        # Done
+        return QtGui.QFont(family, size)
+
+
+# Init
+try:
+    Manager._collectParsers()
+except Exception as why:
+    print('Error collecting parsers')
+    print(why)
diff --git a/simso/gui/codeeditor/misc.py b/simso/gui/codeeditor/misc.py
new file mode 100644
index 0000000..ec9501f
--- /dev/null
+++ b/simso/gui/codeeditor/misc.py
@@ -0,0 +1,100 @@
+# -*- coding: utf-8 -*-
+# Copyright (C) 2013, the codeeditor development team
+#
+# IEP is distributed under the terms of the (new) BSD License.
+# The full license can be found in 'license.txt'.
+
+""" Module misc
+
+Defined ustr (Unicode string) class and the option property decorator.
+
+"""
+
+import sys
+from .qt import QtGui, QtCore
+
+# Set Python version as a float and get some names
+PYTHON_VERSION = sys.version_info[0] + sys.version_info[1]/10.0
+if PYTHON_VERSION < 3:
+    ustr = unicode
+    bstr = str
+    from Queue import Queue, Empty
+else:
+    ustr = str
+    bstr = bytes
+    from queue import Queue, Empty
+
+
+
+DEFAULT_OPTION_NAME = '_ce_default_value'
+DEFAULT_OPTION_NONE = '_+_just some absurd value_+_'
+
+def ce_option(arg1):
+    """ Decorator for properties of the code editor.
+
+    It should be used on the setter function, with its default value
+    as an argument. The default value is then  stored on the function
+    object.
+
+    At the end of the initialization, the base codeeditor class will
+    check all members and (by using the default-value-attribute as a
+    flag) select the ones that are options. These are then set to
+    their default values.
+
+    Similarly this information is used by the setOptions method to
+    know which members are "options".
+
+    """
+
+    # If the decorator is used without arguments, arg1 is the function
+    # being decorated. If arguments are used, arg1 is the argument, and
+    # we should return a callable that is then used as a decorator.
+
+    # Create decorator function.
+    def decorator_fun(f):
+        f.__dict__[DEFAULT_OPTION_NAME] = default
+        return f
+
+    # Handle
+    default = DEFAULT_OPTION_NONE
+    if hasattr(arg1, '__call__'):
+        return decorator_fun(arg1)
+    else:
+        default = arg1
+        return decorator_fun
+
+
+class _CallbackEventHandler(QtCore.QObject):
+    """ Helper class to provide the callLater function.
+    """
+
+    def __init__(self):
+        QtCore.QObject.__init__(self)
+        self.queue = Queue()
+
+    def customEvent(self, event):
+        while True:
+            try:
+                callback, args = self.queue.get_nowait()
+            except Empty:
+                break
+            try:
+                callback(*args)
+            except Exception as why:
+                print('callback failed: {}:\n{}'.format(callback, why))
+
+    def postEventWithCallback(self, callback, *args):
+        self.queue.put((callback, args))
+        QtGui.qApp.postEvent(self, QtCore.QEvent(QtCore.QEvent.User))
+
+
+def callLater(callback, *args):
+    """ callLater(callback, *args)
+
+    Post a callback to be called in the main thread.
+
+    """
+    _callbackEventHandler.postEventWithCallback(callback, *args)
+
+# Create callback event handler instance and insert function in IEP namespace
+_callbackEventHandler = _CallbackEventHandler()
diff --git a/simso/gui/codeeditor/parsers/__init__.py b/simso/gui/codeeditor/parsers/__init__.py
new file mode 100644
index 0000000..f65e41c
--- /dev/null
+++ b/simso/gui/codeeditor/parsers/__init__.py
@@ -0,0 +1,200 @@
+# -*- coding: utf-8 -*-
+# Copyright (C) 2013, the codeeditor development team
+#
+# Codeeditor is distributed under the terms of the (new) BSD License.
+# The full license can be found in 'license.txt'.
+
+""" Subpackage parsers
+
+This subpackage contains all the syntax parsers for the
+different languages. 
+
+"""
+
+
+""" CREATING PARSERS
+
+Making a parser requires these things:
+  * Place a module in the parsers directory, which has a name 
+    ending in "_parser.py"
+  * In the module implement one or more classes that inherit
+    from ..parsers.Parser (or a derived class), and 
+    implement the parseLine method.
+  * The module should import all the tokens in whiches to use 
+    from ..parsers.tokens. New tokens can also be
+    defined by subclassing one of the token classes.
+  * In codeeditor/parsers/__init__.py, add the new module to the 
+    list of imported parsers.
+
+"""
+
+# Normal imports 
+import os, sys
+#import zipfile
+from . import tokens
+
+
+class BlockState(object):
+    """ BlockState(state=0, info=None)
+    
+    The blockstate object should be used by parsers to
+    return the block state of the processed line. 
+    
+    This would typically be the last item to be yielded, but this
+    it may also be yielded befor the last yielded token. One can even
+    yield multiple of these items, in which case the last one considered
+    valid.
+    
+    """
+    isToken = False
+    def __init__(self, state=0, info=None):
+        self._state = int(state)
+        self._info = info
+    
+    @property
+    def state(self):
+        """ The integer value representing the block state.
+        """
+        return self._state
+    
+    @property
+    def info(self):
+        """ Get the information corresponding to the block.
+        """
+        return self._info
+
+
+# Base parser class (needs to be defined before importing parser modules)
+class Parser(object):
+    """ Base parser class. 
+    All parsers should inherit from this class.
+    This base class generates a 'TextToken' for each line
+    """
+    _extensions = []
+    _keywords = []
+    
+    
+    def parseLine(self, line, previousState=0):
+        """ parseLine(line, previousState=0)
+        
+        The method that should be implemented by the parser. The 
+        previousState argument can be used to determine how
+        the previous block ended (e.g. for multiline comments). It
+        is an integer, the meaning of which is only known to the
+        specific parser. 
+        
+        This method should yield token instances. The last token can
+        be a BlockState to specify the previousState for the 
+        next block.
+        
+        """
+        
+        yield tokens.TextToken(line,0,len(line))
+            
+    def name(self):
+        """ name()
+        
+        Get the name of the parser.
+        
+        """
+        name = self.__class__.__name__.lower()
+        if name.endswith('parser'):
+            name = name[:-6]
+        return name
+    
+    
+    def __repr__(self):
+        """ String representation of the parser. 
+        """
+        return '<Parser for "%s">' % self.name()
+    
+    
+    def keywords(self):
+        """ keywords()
+        
+        Get a list of keywords valid for this parser.
+        
+        """
+        return [k for k in self._keywords]
+    
+    
+    def filenameExtensions(self):
+        """ filenameExtensions()
+        
+        Get a list of filename extensions for which this parser
+        is appropriate.
+        
+        """
+        return ['.'+e.lstrip('.').lower() for e in self._extensions]
+    
+    
+    def getStyleElementDescriptions(cls):
+        """ getStyleElementDescriptions()
+        
+        This method returns a list of the StyleElementDescription 
+        instances used by this parser. 
+        
+        """
+        descriptions = {}
+        for token in self.getUsedTokens():
+            descriptions[token.description.key] = token.description
+        
+        return list(descriptions.values())
+    
+    
+    def getUsedTokens(self):
+        """ getUsedTokens()
+        
+        Get a a list of token instances used by this parser.
+        
+        """
+        
+        # Get module object of the parser
+        try:
+            mod = sys.modules[self.__module__]
+        except KeyError:
+            return []
+        
+        # Get token classes from module
+        tokenClasses = []
+        for name in mod.__dict__:
+            member = mod.__dict__[name]
+            if isinstance(member, type) and \
+                                    issubclass(member, tokens.Token):
+                if member is not tokens.Token:
+                    tokenClasses.append(member) 
+        
+        # Return as instances
+        return [t() for t in tokenClasses]
+    
+    
+    def _isTodoItem(self, text):
+        """ _isTodoItem(text)
+        
+        Get whether the given text (which should be a comment) represents
+        a todo item. Todo items start with "todo", "2do" or "fixme", 
+        optionally with a colon at the end.
+        
+        """
+        # Get first word
+        word = text.lstrip().split(' ',1)[0].rstrip(':')
+        # Test
+        if word.lower() in ['todo', '2do', 'fixme']:
+            return True
+        else:
+            return False
+    
+
+## Import parsers statically
+# We could load the parser dynamically from the source files in the 
+# directory, but this takes quite some effort to get righ when apps 
+# are frozen. This is doable (I do it in Visvis) but it requires the
+# user to specify the parser modules by hand when freezing an app.
+#
+# In summary: it takes a lot of trouble, which can be avoided by just
+# listing all parsers here.
+from . import (     python_parser, 
+                    cython_parser,
+                    c_parser,
+                                )
+
diff --git a/simso/gui/codeeditor/parsers/c_parser.py b/simso/gui/codeeditor/parsers/c_parser.py
new file mode 100644
index 0000000..d81444a
--- /dev/null
+++ b/simso/gui/codeeditor/parsers/c_parser.py
@@ -0,0 +1,211 @@
+# -*- coding: utf-8 -*-
+# Copyright (C) 2013, the codeeditor development team
+#
+# IEP is distributed under the terms of the (new) BSD License.
+# The full license can be found in 'license.txt'.
+
+import re
+from . import tokens, Parser, BlockState
+from .tokens import ALPHANUM
+
+from .tokens import (Token, CommentToken, StringToken, 
+    UnterminatedStringToken, IdentifierToken, NonIdentifierToken, KeywordToken,
+    NumberToken)
+
+# todo: compiler directives (or how do you call these things starting with #)
+
+class MultilineCommentToken(CommentToken):
+    """ Characters representing a multi-line comment. """
+    defaultStyle = 'fore:#007F00'
+
+class CharToken(Token):
+    """ Single-quoted char """
+    defaultStyle = 'fore:#7F007F'
+
+
+# This regexp is used to find special stuff, such as comments, numbers and
+# strings.
+tokenProg = re.compile(
+    '([' + ALPHANUM + '_]+)|' +	# Identifiers/numbers (group 1) or
+    '(\/\/)|' +                   # Single line comment (group 2)
+    '(\/\*)|' +                   # Comment (group 3) or
+    '(\'\\\\?.\')|' +  # char (group 4)
+    '(\")'                 # string (group 5)
+    )
+
+
+#For a string, get the RegExp
+#program that matches the end. (^|[^\\]) means: start of the line
+#or something that is not \ (since \ is supposed to escape the following
+#quote) (\\\\)* means: any number of two slashes \\ since each slash will
+#escape the next one
+stringEndProg = re.compile(r'(^|[^\\])(\\\\)*"')
+commentEndProg = re.compile(r'\*/')
+
+class CParser(Parser):
+    """ A C parser.
+    """
+    _extensions = ['.c', '.h', '.cpp', 'cxx', 'hxx']
+    _keywords = ['int', 'const', 'char', 'void', 'short', 'long', 'case']
+    
+    def parseLine(self, line, previousState=0):
+        """ parseLine(line, previousState=0)
+        
+        Parses a line of C code, yielding tokens.
+        
+        """ 
+        
+        pos = 0 # Position following the previous match
+        
+        # identifierState and previousstate values:
+        # 0: nothing special
+        # 1: string
+        # 2: multiline comment /* */
+        
+        # First determine whether we should look for the end of a string,
+        # or if we should process a token.
+        if previousState == 1:
+            token = StringToken(line, 0, 0)
+            tokens = self._findEndOfString(line, token)
+            # Process tokens
+            for token in tokens:
+                yield token
+                if isinstance(token, BlockState):
+                    return 
+            pos = token.end
+        elif previousState == 2:
+            token = MultilineCommentToken(line, 0, 0)
+            tokens = self._findEndOfComment(line, token)
+            # Process tokens
+            for token in tokens:
+                yield token
+                if isinstance(token, BlockState):
+                    return 
+            pos = token.end
+        
+        # Enter the main loop that iterates over the tokens and skips strings
+        while True:
+            
+            # Get next tokens
+            tokens = self._findNextToken(line, pos)
+            if not tokens:
+                return
+            elif isinstance(tokens[-1], StringToken):
+                moreTokens = self._findEndOfString(line, tokens[-1])
+                tokens = tokens[:-1] + moreTokens
+            elif isinstance(tokens[-1], MultilineCommentToken):
+                moreTokens = self._findEndOfComment(line, tokens[-1])
+                tokens = tokens[:-1] + moreTokens
+            
+            # Process tokens
+            for token in tokens:
+                yield token
+                if isinstance(token, BlockState):
+                    return 
+            pos = token.end
+    
+    
+    def _findEndOfComment(self, line, token):
+        """ Find the matching comment end in the rest of the line
+        """
+        
+        # Do not use the start parameter of search, since ^ does not work then
+        
+        endMatch = commentEndProg.search(line, token.end)
+        
+        if endMatch:
+            # The comment does end on this line
+            token.end = endMatch.end()
+            return [token]
+        else:
+            # The comment does not end on this line
+            token.end = len(line)
+            return [token, BlockState(2)]
+    
+    
+    def _findEndOfString(self, line, token):
+        """ Find the matching string end in the rest of the line
+        """
+        
+        # todo: distinguish between single and double quote strings
+        
+        # Find the matching end in the rest of the line
+        # Do not use the start parameter of search, since ^ does not work then
+        endMatch = stringEndProg.search(line[token.end:])
+        
+        if endMatch:
+            # The string does end on this line
+            token.end += endMatch.end()
+            return [token]
+        else:
+            # The string does not end on this line
+            if line.strip().endswith("\\"): #Multi line string
+                token = StringToken(line, token.start, len(line))
+                return [token, BlockState(1)]
+            else:
+                return [UnterminatedStringToken(line, token.start, len(line))]
+
+    
+    
+    def _findNextToken(self, line, pos):
+        """ _findNextToken(line, pos):
+        
+        Returns a token or None if no new tokens can be found.
+        
+        """
+        
+        # Init tokens, if positing too large, stop now
+        if pos > len(line):
+            return None
+        tokens = []
+        
+        # Find the start of the next string or comment
+        match = tokenProg.search(line, pos)
+        
+        # Process the Non-Identifier between pos and match.start() 
+        # or end of line
+        nonIdentifierEnd = match.start() if match else len(line)
+        
+        # Return the Non-Identifier token if non-null
+        token = NonIdentifierToken(line,pos,nonIdentifierEnd)
+        if token:
+            tokens.append(token)
+        
+        # If no match, we are done processing the line
+        if not match:
+            return tokens
+        
+        # The rest is to establish what identifier we are dealing with
+        
+        # Identifier ("a word or number") Find out whether it is a key word
+        if match.group(1) is not None:
+            identifier = match.group(1)
+            tokenArgs = line, match.start(), match.end()
+            
+            if identifier in self._keywords: 
+                tokens.append( KeywordToken(*tokenArgs) )
+            elif identifier[0] in '0123456789':
+                identifierState = 0
+                tokens.append( NumberToken(*tokenArgs) )
+            else:
+                tokens.append( IdentifierToken(*tokenArgs) )
+        
+        # Single line comment
+        elif match.group(2) is not None:
+            tokens.append( CommentToken(line,match.start(),len(line)) )
+        elif match.group(3) is not None:
+            tokens.append( MultilineCommentToken(line,match.start(),match.end()) )
+        elif match.group(4) is not None: # Char
+            tokens.append( CharToken(line,match.start(),match.end()) )
+        else:
+            # We have matched a string-start
+            tokens.append( StringToken(line,match.start(),match.end()) )
+        
+        # Done
+        return tokens
+
+
+if __name__=='__main__':
+    parser = CParser()
+    for token in parser.parseLine('void test(int i=2) /* test '):
+        print ("%s %s" % (token.name, token))
diff --git a/simso/gui/codeeditor/parsers/cython_parser.py b/simso/gui/codeeditor/parsers/cython_parser.py
new file mode 100644
index 0000000..56ec6f7
--- /dev/null
+++ b/simso/gui/codeeditor/parsers/cython_parser.py
@@ -0,0 +1,74 @@
+# -*- coding: utf-8 -*-
+# Copyright (C) 2013, the codeeditor development team
+#
+# IEP is distributed under the terms of the (new) BSD License.
+# The full license can be found in 'license.txt'.
+
+import re
+from . import tokens, Parser, BlockState
+from .tokens import ALPHANUM
+
+
+# Import tokens in module namespace
+from .tokens import (CommentToken, StringToken, 
+    UnterminatedStringToken, IdentifierToken, NonIdentifierToken,
+    KeywordToken, NumberToken, FunctionNameToken, ClassNameToken,
+    TodoCommentToken)
+
+from .python_parser import (  PythonParser,
+                                                MultilineStringToken,
+                                                CellCommentToken,
+                                                pythonKeywords)
+
+# Set keywords
+cythonExtraKeywords = set(['cdef', 'cpdef', 'ctypedef', 'cimport',
+                    'float', 'double', 'int', 'long'])
+
+
+class CythonParser(PythonParser):
+    """ Parser for Cython/Pyrex.
+    """
+    _extensions = ['pyi', '.pyx' , '.pxd']
+    
+    _keywords = pythonKeywords | cythonExtraKeywords
+    
+    
+    def _identifierState(self, identifier=None):
+        """ Given an identifier returs the identifier state:
+        3 means the current identifier can be a function.
+        4 means the current identifier can be a class.
+        0 otherwise.
+        
+        This method enables storing the state during the line,
+        and helps the Cython parser to reuse the Python parser's code.
+        
+        This implementation keeps a counter. If the counter is 0, the
+        state is zero.
+        """
+        if identifier is None:
+            # Explicit get and reset
+            state = 0
+            try:
+                if self._idsCounter>0:
+                    state = self._idsState
+            except Exception:
+                pass            
+            self._idsState = 0
+            self._idsCounter = 0
+            return state
+        elif identifier in ['def', 'cdef', 'cpdef']:
+            # Set function state
+            self._idsState = 3
+            self._idsCounter = 2
+            return 3
+        elif identifier == 'class':
+            # Set class state
+            self._idsState = 4
+            self._idsCounter = 1
+            return 4
+        elif self._idsCounter>0:
+            self._idsCounter -= 1
+            return self._idsState
+        else:
+            # This one can be func or class, next one can't
+            return 0
diff --git a/simso/gui/codeeditor/parsers/python_parser.py b/simso/gui/codeeditor/parsers/python_parser.py
new file mode 100644
index 0000000..06807c1
--- /dev/null
+++ b/simso/gui/codeeditor/parsers/python_parser.py
@@ -0,0 +1,354 @@
+# -*- coding: utf-8 -*-
+# Copyright (C) 2013, the codeeditor development team
+#
+# IEP is distributed under the terms of the (new) BSD License.
+# The full license can be found in 'license.txt'.
+
+import re
+from . import tokens, Parser, BlockState
+from .tokens import ALPHANUM
+
+
+# Import tokens in module namespace
+from .tokens import (CommentToken, StringToken,
+    UnterminatedStringToken, IdentifierToken, NonIdentifierToken,
+    KeywordToken, NumberToken, FunctionNameToken, ClassNameToken,
+    TodoCommentToken)
+
+# Keywords sets
+
+# Source: import keyword; keyword.kwlist (Python 2.6.6)
+python2Keywords = set(['and', 'as', 'assert', 'break', 'class', 'continue',
+        'def', 'del', 'elif', 'else', 'except', 'exec', 'finally', 'for',
+        'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'not', 'or',
+        'pass', 'print', 'raise', 'return', 'try', 'while', 'with', 'yield'])
+
+# Source: import keyword; keyword.kwlist (Python 3.1.2)
+python3Keywords = set(['False', 'None', 'True', 'and', 'as', 'assert', 'break',
+        'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally',
+        'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda',
+        'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while',
+        'with', 'yield'])
+
+# Merge the two sets to get a general Python keyword list
+pythonKeywords = python2Keywords | python3Keywords
+
+
+def qstring_to_unicode(s):
+    try:
+        return unicode(s)
+    except NameError:
+        return s
+
+
+class MultilineStringToken(StringToken):
+    """ Characters representing a multi-line string. """
+    defaultStyle = 'fore:#7F0000'
+
+class CellCommentToken(CommentToken):
+    """ Characters representing a cell separator comment: "##". """
+    defaultStyle = 'bold:yes, underline:yes'
+
+
+
+# This regexp is used to find special stuff, such as comments, numbers and
+# strings.
+tokenProg = re.compile(
+    '#|' +						# Comment or
+    '([' + ALPHANUM + '_]+)|' +	# Identifiers/numbers (group 1) or
+    '(' +  						# Begin of string group (group 2)
+    '([bB]|[uU])?' +			# Possibly bytes or unicode (py2.x)
+    '[rR]?' +					# Possibly a raw string
+    '("""|\'\'\'|"|\')' +		# String start (triple qoutes first, group 4)
+    ')'							# End of string group
+    )
+
+
+#For a given type of string ( ', " , ''' , """ ),get  the RegExp
+#program that matches the end. (^|[^\\]) means: start of the line
+#or something that is not \ (since \ is supposed to escape the following
+#quote) (\\\\)* means: any number of two slashes \\ since each slash will
+#escape the next one
+endProgs = {
+    "'": re.compile(r"(^|[^\\])(\\\\)*'"),
+    '"': re.compile(r'(^|[^\\])(\\\\)*"'),
+    "'''": re.compile(r"(^|[^\\])(\\\\)*'''"),
+    '"""': re.compile(r'(^|[^\\])(\\\\)*"""')
+    }
+
+
+class PythonParser(Parser):
+    """ Parser for Python in general (2.x or 3.x).
+    """
+    _extensions = ['.py' , '.pyw']
+    #The list of keywords is overridden by the Python2/3 specific parsers
+    _keywords = pythonKeywords
+
+
+    def _identifierState(self, identifier=None):
+        """ Given an identifier returs the identifier state:
+        3 means the current identifier can be a function.
+        4 means the current identifier can be a class.
+        0 otherwise.
+
+        This method enables storing the state during the line,
+        and helps the Cython parser to reuse the Python parser's code.
+        """
+        if identifier is None:
+            # Explicit get/reset
+            try:
+                state = self._idsState
+            except Exception:
+                state = 0
+            self._idsState = 0
+            return state
+        elif identifier == 'def':
+            # Set function state
+            self._idsState = 3
+            return 3
+        elif identifier == 'class':
+            # Set class state
+            self._idsState = 4
+            return 4
+        else:
+            # This one can be func or class, next one can't
+            state = self._idsState
+            self._idsState = 0
+            return state
+
+
+    def parseLine(self, line, previousState=0):
+        """ parseLine(line, previousState=0)
+
+        Parse a line of Python code, yielding tokens.
+        previousstate is the state of the previous block, and is used
+        to handle line continuation and multiline strings.
+
+        """
+
+        # Init
+        pos = 0 # Position following the previous match
+
+        # identifierState and previousstate values:
+        # 0: nothing special
+        # 1: multiline comment single qoutes
+        # 2: multiline comment double quotes
+        # 3: a def keyword
+        # 4: a class keyword
+
+        #Handle line continuation after def or class
+        #identifierState is 3 or 4 if the previous identifier was 3 or 4
+        if previousState == 3 or previousState == 4:
+            self._identifierState({3:'def',4:'class'}[previousState])
+        else:
+            self._identifierState(None)
+
+        if previousState in [1,2]:
+            token = MultilineStringToken(line, 0, 0)
+            token._style = ['', "'''", '"""'][previousState]
+            tokens = self._findEndOfString(line, token)
+            # Process tokens
+            for token in tokens:
+                yield token
+                if isinstance(token, BlockState):
+                    return
+            pos = token.end
+
+
+        # Enter the main loop that iterates over the tokens and skips strings
+        while True:
+
+            # Get next tokens
+            tokens = self._findNextToken(line, pos)
+            if not tokens:
+                return
+            elif isinstance(tokens[-1], StringToken):
+                moreTokens = self._findEndOfString(line, tokens[-1])
+                tokens = tokens[:-1] + moreTokens
+
+            # Process tokens
+            for token in tokens:
+                yield token
+                if isinstance(token, BlockState):
+                    return
+            pos = token.end
+
+
+    def _findEndOfString(self, line, token):
+        """ _findEndOfString(line, token)
+
+        Find the end of a string. Returns (token, endToken). The first
+        is the given token or a replacement (UnterminatedStringToken).
+        The latter is None, or the BlockState. If given, the line is
+        finished.
+
+        """
+
+        # Set state
+        self._identifierState(None)
+
+        # Find the matching end in the rest of the line
+        # Do not use the start parameter of search, since ^ does not work then
+        style = token._style
+        endMatch = endProgs[style].search(line[token.end:])
+
+        if endMatch:
+            # The string does end on this line
+            tokenArgs = line, token.start, token.end + endMatch.end()
+            if style in ['"""', "'''"]:
+                token = MultilineStringToken(*tokenArgs)
+            else:
+                token.end += endMatch.end()
+            return [token]
+        else:
+            # The string does not end on this line
+            tokenArgs = line, token.start, token.end + len(line)
+            if style == "'''":
+                return [MultilineStringToken(*tokenArgs), BlockState(1)]
+            elif style == '"""':
+                return [MultilineStringToken(*tokenArgs), BlockState(2)]
+            else:
+                return [UnterminatedStringToken(*tokenArgs)]
+
+
+    def _findNextToken(self, line, pos):
+        """ _findNextToken(line, pos):
+
+        Returns a token or None if no new tokens can be found.
+
+        """
+
+        line = qstring_to_unicode(line)
+
+        # Init tokens, if pos too large, were done
+        if pos > len(line):
+            return None
+        tokens = []
+
+        # Find the start of the next string or comment
+        match = tokenProg.search(line, pos)
+
+        # Process the Non-Identifier between pos and match.start()
+        # or end of line
+        nonIdentifierEnd = match.start() if match else len(line)
+
+        # Return the Non-Identifier token if non-null
+        # todo: here it goes wrong (allow returning more than one token?)
+        token = NonIdentifierToken(line,pos,nonIdentifierEnd)
+        strippedNonIdentifier = str(token).strip()
+        if token:
+            tokens.append(token)
+
+        # Do checks for line continuation and identifierState
+        # Is the last non-whitespace a line-continuation character?
+        if strippedNonIdentifier.endswith('\\'):
+            lineContinuation = True
+            # If there are non-whitespace characters after def or class,
+            # cancel the identifierState
+            if strippedNonIdentifier != '\\':
+                self._identifierState(None)
+        else:
+            lineContinuation = False
+            # If there are non-whitespace characters after def or class,
+            # cancel the identifierState
+            if strippedNonIdentifier != '':
+                self._identifierState(None)
+
+        # If no match, we are done processing the line
+        if not match:
+            if lineContinuation:
+                tokens.append( BlockState(self._identifierState()) )
+            return tokens
+
+        # The rest is to establish what identifier we are dealing with
+
+        # Comment
+        if match.group() == '#':
+            matchStart = match.start()
+            if ( line[matchStart:].startswith('##') and
+                    not line[:matchStart].strip() ):
+                tokens.append( CellCommentToken(line,matchStart,len(line)) )
+            elif self._isTodoItem(line[matchStart+1:]):
+                tokens.append( TodoCommentToken(line,matchStart,len(line)) )
+            else:
+                tokens.append( CommentToken(line,matchStart,len(line)) )
+            if lineContinuation:
+                tokens.append( BlockState(self._identifierState()) )
+            return tokens
+
+        # If there are non-whitespace characters after def or class,
+        # cancel the identifierState (this time, also if there is just a \
+        # since apparently it was not on the end of a line)
+        if strippedNonIdentifier != '':
+            self._identifierState(None)
+
+        # Identifier ("a word or number") Find out whether it is a key word
+        if match.group(1) is not None:
+            identifier = match.group(1)
+            tokenArgs = line, match.start(), match.end()
+
+            # Set identifier state
+            identifierState = self._identifierState(identifier)
+
+            if identifier in self._keywords:
+                tokens.append( KeywordToken(*tokenArgs) )
+            elif identifier[0] in '0123456789':
+                self._identifierState(None)
+                tokens.append( NumberToken(*tokenArgs) )
+            else:
+                if (identifierState==3 and
+                        line[match.end():].lstrip().startswith('(') ):
+                    tokens.append( FunctionNameToken(*tokenArgs) )
+                elif identifierState==4:
+                    tokens.append( ClassNameToken(*tokenArgs) )
+                else:
+                    tokens.append( IdentifierToken(*tokenArgs) )
+
+        else:
+            # We have matched a string-start
+            # Find the string style ( ' or " or ''' or """)
+            token = StringToken(line, match.start(), match.end())
+            token._style = match.group(4) # The style is in match group 4
+            tokens.append( token )
+
+        # Done
+        return tokens
+
+
+class Python2Parser(PythonParser):
+    """ Parser for Python 2.x code.
+    """
+     # The application should choose whether to set the Py 2 specific parser
+    _extensions = []
+    _keywords = python2Keywords
+
+class Python3Parser(PythonParser):
+    """ Parser for Python 3.x code.
+    """
+    # The application should choose whether to set the Py 3 specific parser
+    _extensions = []
+    _keywords = python3Keywords
+
+
+if __name__=='__main__':
+    print(list(tokenizeLine('this is "String" #Comment')))
+    print(list(tokenizeLine('this is "String\' #Comment')))
+    print(list(tokenizeLine('this is "String\' #Commen"t')))
+    print(list(tokenizeLine(r'this "test\""')))
+
+    import random
+    stimulus=''
+    expect=[]
+    for i in range(10):
+        #Create a string with lots of ' and "
+        s=''.join("'\"\\ab#"[random.randint(0,5)] for i in range(10)  )
+        stimulus+=repr(s)
+        expect.append('S:'+repr(s))
+        stimulus+='test'
+        expect.append('I:test')
+    result=list(tokenizeLine(stimulus))
+    print (stimulus)
+    print (expect)
+    print (result)
+
+    assert repr(result) == repr(expect)
diff --git a/simso/gui/codeeditor/parsers/tokens.py b/simso/gui/codeeditor/parsers/tokens.py
new file mode 100644
index 0000000..a1f7b99
--- /dev/null
+++ b/simso/gui/codeeditor/parsers/tokens.py
@@ -0,0 +1,149 @@
+# -*- coding: utf-8 -*-
+# Copyright (C) 2013, the codeeditor development team
+#
+# IEP is distributed under the terms of the (new) BSD License.
+# The full license can be found in 'license.txt'.
+
+""" Module tokens
+
+Defines the base Token class and a few generic tokens.
+Tokens are used by parsers to identify for groups of characters
+what they represent. This is in turn used by the highlighter
+to determine how these characters should be styled.
+
+"""
+
+# Many parsers need this
+ALPHANUM = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
+
+import sys
+from ..style import StyleFormat, StyleElementDescription
+from ..misc import ustr, bstr
+
+
+class Token(object):
+    """ Token(line, start, end)
+
+    Base token class.
+
+    A token is a group of characters representing "something".
+    What is represented, is specified by the subclass.
+
+    Each token class should have a docstring describing the meaning
+    of the characters it is applied to.
+
+    """
+    defaultStyle = 'fore:#000, bold:no, underline:no, italic:no'
+    isToken = True # For the BlockState object, which is also returned by the parsers, this is False
+    def __init__(self, line='', start=0, end=0):
+        self.line = ustr(line)
+        self.start = start
+        self.end = end
+        self._name = self._getName()
+
+    if sys.version_info[0] >= 3:  # Python 3
+        def __str__(self):
+            return self.__unicode__()
+    else:  # Python 2
+        def __str__(self):
+            return self.__unicode__().encode('utf8')
+
+    def __unicode__(self):
+        return self.line[self.start:self.end]
+
+    def __repr__(self):
+        return repr('%s:%s' % (self.name, self))
+
+    def __len__(self):
+        # Defining a length also gives a Token a boolean value: True if there
+        # are any characters (len!=0) and False if there are none
+        return self.end - self.start
+
+    def _getName(self):
+        """ Get the name of this token. """
+        nameParts = ['Syntax']
+        if '_parser' in self.__module__:
+            language = self.__module__.split('_')[0]
+            language = language.split('.')[-1]
+            nameParts.append( language[0].upper() + language[1:] )
+        nameParts.append( self.__class__.__name__[:-5].lower() )
+        return '.'.join(nameParts)
+
+    def getDefaultStyleFormat(self):
+        elements = []
+        def collect(cls):
+            if hasattr(cls, 'defaultStyle'):
+                elements.append(cls.defaultStyle)
+                for c in cls.__bases__:
+                    collect(c)
+        collect(self.__class__)
+        se = StyleFormat()
+        for e in reversed(elements):
+            se.update(e)
+        return se
+
+    @property
+    def name(self):
+        """ The name of this token. Used to identify it and attach a style.
+        """
+        return self._name
+
+    @property
+    def description(self):
+        """ description()
+
+        Returns a StyleElementDescription instance that describes the
+        style element that this token represents.
+
+        """
+        format = self.getDefaultStyleFormat()
+        des = 'syntax: ' + self.__doc__
+        return StyleElementDescription(self.name, des, str(format))
+
+
+class CommentToken(Token):
+    """ Characters representing a comment in the code. """
+    defaultStyle = 'fore:#007F00'
+
+class TodoCommentToken(CommentToken):
+    """ Characters representing a comment in the code. """
+    defaultStyle = 'fore:#E00,italic'
+
+class StringToken(Token):
+    """ Characters representing a textual string in the code. """
+    defaultStyle = 'fore:#7F007F'
+
+class UnterminatedStringToken(StringToken):
+    """ Characters belonging to an unterminated string. """
+    defaultStyle = 'underline:dotted'
+
+# todo: request from user: whitespace token
+
+class TextToken(Token):
+    """ Anything that is not a string or comment. """
+    defaultStyle = 'fore:#000'
+
+class IdentifierToken(TextToken):
+    """ Characters representing normal text (i.e. words). """
+    defaultStyle = ''
+
+class NonIdentifierToken(TextToken):
+    """ Not a word (operators, whitespace, etc.). """
+    defaultStyle = ''
+
+class KeywordToken(IdentifierToken):
+    """ A keyword is a word with a special meaning to the language. """
+    defaultStyle = 'fore:#00007F, bold:yes'
+
+class NumberToken(IdentifierToken):
+    """ Characters represening a number. """
+    defaultStyle = 'fore:#007F7F'
+
+class FunctionNameToken(IdentifierToken):
+    """ Characters represening the name of a function. """
+    defaultStyle = 'fore:#007F7F, bold:yes'
+
+class ClassNameToken(IdentifierToken):
+    """ Characters represening the name of a class. """
+    defaultStyle = 'fore:#0000FF, bold:yes'
+
diff --git a/simso/gui/codeeditor/qt.py b/simso/gui/codeeditor/qt.py
new file mode 100644
index 0000000..91e3347
--- /dev/null
+++ b/simso/gui/codeeditor/qt.py
@@ -0,0 +1,19 @@
+import sys
+# Simple module to allow using both PySide and PyQt4
+
+try:
+    # This is a proper proxy
+    from pyzolib.qt import QtCore, QtGui
+except ImportError:
+    try:
+        #if sys.platform == 'darwin':
+        #    raise ImportError # PySide causes crashes on Mac OS X
+        
+        from PySide import QtCore, QtGui
+    except ImportError:
+        try:
+            from PyQt4 import QtCore, QtGui
+            QtCore.Signal = QtCore.pyqtSignal # Define signal as pyqtSignal
+        except ImportError:
+            raise ImportError("Both PySide and PyQt4 could not be imported.")
+
diff --git a/simso/gui/codeeditor/style.py b/simso/gui/codeeditor/style.py
new file mode 100644
index 0000000..61942b9
--- /dev/null
+++ b/simso/gui/codeeditor/style.py
@@ -0,0 +1,255 @@
+# -*- coding: utf-8 -*-
+# Copyright (C) 2013, the codeeditor development team
+#
+# IEP is distributed under the terms of the (new) BSD License.
+# The full license can be found in 'license.txt'.
+
+""" Modyule style
+
+Provides basic functionaliy for styling.
+
+Styling is done using a dictionary of StyleFormat instances. Each 
+such instance reprsents a certain element being styled (e.g. keywords, 
+line numbers, indentation guides). 
+
+All possible style elements are represented using StyleElementDescription 
+instances. These have a name, description and default format, which
+makes it easy to build a UI to allow the user to change the syle.
+
+"""
+from .qt import QtGui, QtCore
+Qt = QtCore.Qt
+
+
+class StyleElementDescription:
+    """ StyleElementDescription(name, defaultFormat, description)
+    
+    Describes a style element by its name, default format, and description.
+    
+    A style description is a simple placeholder for something
+    that can be styled.
+    
+    """
+    
+    def __init__(self, name, description, defaultFormat):
+        self._name = name
+        self._description = description
+        self._defaultFormat = StyleFormat(defaultFormat)
+    
+    def __repr__(self):
+        return '<"%s": "%s">' % (self.name, self.defaultFormat)
+    
+    @property
+    def name(self):
+        return self._name
+    
+    @property
+    def key(self):
+        return self._name.replace(' ', '').lower()
+    
+    @property
+    def description(self):
+        return self._description
+    
+    @property
+    def defaultFormat(self):
+        return self._defaultFormat
+
+
+class StyleFormat:
+    """ StyleFormat(format='')
+    
+    Represents the style format for a specific style element.
+    A "style" is a dictionary that maps names (of style elements) 
+    to StyleFormat instances.
+    
+    The given format can be a string or another StyleFormat instance.
+    Style formats can be combined using their update() method. 
+    
+    A style format consists of multiple parts, where each "part" consists
+    of a key and a value. The keys can be anything, depending
+    on what kind of thing is being styled. The value can be obtained using
+    the index operator (e.g. styleFomat['fore'])
+    
+    For a few special keys, properties are defined that return the Qt object
+    corresponding to the value. These values are also buffered to enable
+    fast access. These keys are:
+      * fore: (QColor) the foreground color
+      * back: (QColor) the background color
+      * bold: (bool) whether the text should be bold
+      * italic: (bool) whether the text should be in italic
+      * underline: (int) whether an underline should be used (and which one)
+      * linestyle: (int) what line style to use (e.g. for indent guides)
+      * textCharFOrmat: (QTextCharFormat) for the syntax styles
+    
+    The format neglects spaces and case. Parts are separated by commas 
+    or semicolons. If only a key is given it's value is interpreted
+    as 'yes'. If only a color is given, its key is interpreted as 'fore' 
+    and back. Colors should be given using the '#' hex formatting.
+    
+    An example format string: 'fore:#334, bold, underline:dotLine'
+    
+    By calling str(styleFormatInstance) the string representing of the 
+    format can be obtained. By iterating over the instance, a series 
+    of key-value pairs is obtained.
+    
+    """
+    
+    def __init__(self, format=''):
+        self._parts = {}
+        self.update(format)
+    
+    
+    def _resetProperties(self):
+        self._fore = None
+        self._back = None
+        self._bold = None
+        self._italic = None
+        self._underline = None
+        self._linestyle = None
+        self._textCharFormat = None
+    
+    
+    def __str__(self):
+        """ Get a (cleaned up) string representation of this style format. 
+        """
+        parts = []
+        for key in self._parts:
+            parts.append('%s:%s' % (key, self._parts[key]))
+        return ', '.join(parts)
+    
+    
+    def __repr__(self):
+        return '<StyleFormat "%s">' % str(self)
+    
+    
+    def __getitem__(self, key):
+        try:
+            return self._parts[key]
+        except KeyError:
+            raise KeyError('Invalid part key for style format.')
+    
+    def __iter__(self):
+        """ Yields a series of tuples (key, val).
+        """
+        parts = []
+        for key in self._parts:
+            parts.append( (key, self._parts[key]) )
+        return parts.__iter__()
+    
+    
+    def update(self, format):
+        """ update(format)
+        
+        Update this style format with the given format.
+        
+        """
+        
+        # Reset buffered values
+        self._resetProperties()
+        
+        # Make a string, so we update the format with the given one
+        if isinstance(format, StyleFormat):
+            format = str(format)
+        
+        # Split on ',' and ',', ignore spaces
+        styleParts = [p for p in
+                        format.replace('=',':').replace(';',',').split(',')]
+        
+        for stylePart in styleParts:
+            
+            # Make sure it consists of identifier and value pair
+            # e.g. fore:#xxx, bold:yes, underline:no
+            if not ':' in stylePart:
+                if stylePart.startswith('#'):
+                    stylePart = 'foreandback:' + stylePart
+                else:
+                    stylePart += ':yes'
+            
+            # Get key value and strip and make lowecase
+            key, _, val = [i.strip().lower() for i in stylePart.partition(':')]
+            
+            # Store in parts
+            if key == 'foreandback':
+                self._parts['fore'] = val
+                self._parts['back'] = val
+            elif key:
+                self._parts[key] = val
+    
+    ## Properties
+    
+    def _getValueSafe(self, key):
+        try:
+            return self._parts[key]
+        except KeyError:
+            return 'no'
+    
+    @property
+    def fore(self):
+        if self._fore is None:
+            self._fore = QtGui.QColor(self._parts['fore'])
+        return self._fore
+    
+    @property
+    def back(self):
+        if self._back is None:
+            self._back = QtGui.QColor(self._parts['back'])
+        return self._back
+    
+    @property
+    def bold(self):
+        if self._bold is None:
+            if self._getValueSafe('bold') in ['yes', 'true']:
+                self._bold = True
+            else:
+                self._bold = False
+        return self._bold
+    
+    @property
+    def italic(self):
+        if self._italic is None:
+            if self._getValueSafe('italic') in ['yes', 'true']:
+                self._italic = True
+            else:
+                self._italic = False
+        return self._italic
+    
+    @property
+    def underline(self):
+        if self._underline is None:
+            val = self._getValueSafe('underline')
+            if val in ['yes', 'true']:
+                self._underline = QtGui.QTextCharFormat.SingleUnderline
+            elif val in ['dotted', 'dots', 'dotline']: 
+                self._underline = QtGui.QTextCharFormat.DotLine
+            elif val in ['wave']: 
+                self._underline = QtGui.QTextCharFormat.WaveUnderline
+            else:
+                self._underline = QtGui.QTextCharFormat.NoUnderline
+        return self._underline
+    
+    @property
+    def linestyle(self):
+        if self._linestyle is None:
+            val = self._getValueSafe('linestyle')
+            if val in ['yes', 'true']:
+                self._linestyle = Qt.SolidLine
+            elif val in ['dotted', 'dot', 'dots', 'dotline']: 
+                self._linestyle = Qt.DotLine
+            elif val in ['dashed', 'dash', 'dashes', 'dashline']: 
+                self._linestyle = Qt.DashLine
+            else:
+                self._linestyle = Qt.SolidLine # default to solid
+        return self._linestyle
+    
+    @property
+    def textCharFormat(self):
+        if self._textCharFormat is None:
+            self._textCharFormat = tcf = QtGui.QTextCharFormat()
+            self._textCharFormat.setForeground(self.fore)
+            self._textCharFormat.setUnderlineStyle(self.underline)
+            if self.bold:
+                self._textCharFormat.setFontWeight(QtGui.QFont.Bold)
+            if self.italic:
+                self._textCharFormat.setFontItalic(True)
+        return self._textCharFormat
diff --git a/simso/gui/codeeditor/textutils.py b/simso/gui/codeeditor/textutils.py
new file mode 100644
index 0000000..857e3b4
--- /dev/null
+++ b/simso/gui/codeeditor/textutils.py
@@ -0,0 +1,184 @@
+# -*- coding: utf-8 -*-
+# Copyright (C) 2013, the IEP development team
+#
+# IEP is distributed under the terms of the (new) BSD License.
+# The full license can be found in 'license.txt'.
+
+
+class TextReshaper:
+    """ Object to reshape a piece of text, taking indentation, paragraphs, 
+    comments and bulletpoints into account.
+    """
+    
+    def __init__(self, lw, margin=3):
+        self.lw = lw
+        self.margin = margin
+        
+        self._lines1 = []
+        self._lines2 = []
+        
+        self._wordBuffer = []
+        self._charsInBuffer = -1 # First word ads one extra
+        
+        self._pendingPrefix = None # A one-shot prefix
+        self._currentPrefix = None # The prefix used until a new prefix is set
+    
+    @classmethod
+    def reshapeText(cls, text, lw):
+        tr = cls(lw)
+        tr.pushText(text)
+        return tr.popText()
+    
+    def pushLine(self, line):
+        """ Push a single line to the input.
+        """
+        self._lines1.append(line.rstrip())
+    
+    def pushText(self, text):
+        """ Push a (multiline) text to the input.
+        """
+        for line in text.splitlines():
+            self.pushLine(line)
+    
+    def popLines(self):
+        """ Get all available lines from the output.
+        """
+        try:
+            while True:
+                self._popLine()
+        except StopIteration:
+            self._flush()
+        
+        return [line for line in self._lines2]
+    
+    def popText(self):
+        """ Get all text from the output (i.e. lines joined with newline).
+        """
+        return '\n'.join(self.popLines())
+    
+    
+    def _prefixString(self):
+        if self._pendingPrefix is not None:
+            prefix = self._pendingPrefix
+            self._pendingPrefix = None
+            return prefix
+        else:
+            return self._currentPrefix or ''
+    
+    def _addWordToBuffer(self, word):
+        self._wordBuffer.append(word)
+        self._charsInBuffer += len(word) + 1 # add one for space
+    
+    def _flush(self):
+        if self._wordBuffer:
+            self._lines2.append(self._prefixString() + ' '.join(self._wordBuffer))
+        self._wordBuffer, self._charsInBuffer = [], -1
+    
+    def _addNewParagraph(self):
+        # Flush remaining words
+        self._flush()
+        # Create empty line
+        prefix = self._currentPrefix or ''
+        prefix = ' ' * len(prefix)
+        self._lines2.append(prefix)
+        # Allow new prefix
+        self._currentPrefix = None
+    
+    def _popLine(self):
+        """ Pop a line from the input. Examine how it starts and convert it
+        to words.
+        """
+        
+        # Pop line
+        try:
+            line = self._lines1.pop(0)
+        except IndexError:
+            raise StopIteration()
+        
+        # Strip the line
+        strippedline1 = line.lstrip()
+        strippedline2 = line.lstrip(' \t#*')
+        
+        # Analyze this line (how does it start?)
+        if not strippedline1:
+            self._addNewParagraph()
+            return
+        elif strippedline1.startswith('* '):
+            self._flush()
+            indent = len(line) - len(strippedline1)
+            linePrefix = line[:indent]
+            self._pendingPrefix = linePrefix + '* '
+            self._currentPrefix = linePrefix + '  '
+        else:
+            # Hey, an actual line! Determine prefix
+            indent = len(line) - len(strippedline1)
+            linePrefix = line[:indent]
+            # Check comments
+            if strippedline1.startswith('#'):
+                linePrefix += '# '
+            # What to do now?
+            if linePrefix != self._currentPrefix:
+                self._flush()
+                self._currentPrefix = linePrefix
+        
+        
+        # Process words one by one...
+        for word in strippedline2.split(' '):
+            self._addWordToBuffer(word)
+            currentLineWidth = self._charsInBuffer + len(self._currentPrefix)
+            
+            if currentLineWidth < self.lw:
+                # Not enough words in buffer yet
+                pass 
+            elif len(self._wordBuffer) > 1:
+                # Enough words to compose a line
+                marginWith = currentLineWidth - self.lw
+                marginWithout = self.lw - (currentLineWidth - len(word))
+                if marginWith < marginWithout and marginWith < self.margin:
+                    # add all buffered words
+                    self._flush()
+                else:
+                    # add all buffered words (except last)
+                    self._wordBuffer.pop(-1)
+                    self._flush()
+                    self._addWordToBuffer(word)
+            else:
+                # This single word covers more than one line
+                self._flush()
+    
+
+
+testText = """
+
+# This is a piece
+# of comment
+Lorem ipsum dolor sit amet, consectetur 
+adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi 
+ut aliquip ex ea 
+commodo consequat. Duis aute irure dolor 
+in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat 
+non proident, sunt in culpa qui officia deserunt mollit anim 
+id est laborum.
+
+        # Indented comments 
+        # should work
+        # as well
+    
+skdb-a-very-long-word-ksdbfksasdvbassdfhjsdfbjdfbvhjdbvhjbdfhjvbdfjbvjdfbvjdfbvjdbfvj
+
+   A change in indentation makes it a separate line 
+sdckj bsdkjcb sdc
+sdckj  foo bar
+aap noot mies
+
+  * Bullet points are preserved
+  * Even if they are very long the should be preserved. I know that brevity is a great virtue but you know, 
+    sometimes you just need those 
+    extra words to make a point.
+
+"""
+
+if __name__ == '__main__':
+    print(TextReshaper.reshapeText(testText, 70))
+    
+    
\ No newline at end of file
